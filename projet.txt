
# ARBORESCENCE
#
/home/tilnede0x1182/code/tilnede0x1182/Personnel/2025/Entrainement/plant_shop/Javascript/NuxtJS/plant_shop_nuxtjs
â”œâ”€â”€ app
â”œâ”€â”€ app.html
â”œâ”€â”€ app.vue
â”œâ”€â”€ components
â”‚Â Â  â”œâ”€â”€ CartWidget.vue
â”‚Â Â  â”œâ”€â”€ FlashMessages.vue
â”‚Â Â  â”œâ”€â”€ Navbar.vue
â”‚Â Â  â””â”€â”€ UserMenu.vue
â”œâ”€â”€ composables
â”‚Â Â  â””â”€â”€ useCart.ts
â”œâ”€â”€ import-test.ts
â”œâ”€â”€ layouts
â”‚Â Â  â””â”€â”€ default.vue
â”œâ”€â”€ Makefile
â”œâ”€â”€ nuxt.config.ts
â”œâ”€â”€ package.json
â”œâ”€â”€ pages
â”‚Â Â  â”œâ”€â”€ admin
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ plants
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ [id]
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ edit.vue
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ [id].vue
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.vue
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ new.vue
â”‚Â Â  â”‚Â Â  â””â”€â”€ users
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ [id]
â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ edit.vue
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ [id].vue
â”‚Â Â  â”‚Â Â      â””â”€â”€ index.vue
â”‚Â Â  â”œâ”€â”€ auth
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ register.vue
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ signin.vue
â”‚Â Â  â”‚Â Â  â””â”€â”€ unauthorized.vue
â”‚Â Â  â”œâ”€â”€ bootstrap-check.vue
â”‚Â Â  â”œâ”€â”€ cart.vue
â”‚Â Â  â”œâ”€â”€ index.vue
â”‚Â Â  â”œâ”€â”€ orders
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.vue
â”‚Â Â  â”‚Â Â  â””â”€â”€ new.vue
â”‚Â Â  â”œâ”€â”€ plants
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ [id]
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ edit.vue
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ [id].vue
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.vue
â”‚Â Â  â”‚Â Â  â””â”€â”€ new.vue
â”‚Â Â  â””â”€â”€ users
â”‚Â Â      â”œâ”€â”€ [id]
â”‚Â Â      â”‚Â Â  â””â”€â”€ edit.vue
â”‚Â Â      â””â”€â”€ [id].vue
â”œâ”€â”€ prisma
â”‚Â Â  â”œâ”€â”€ migrations
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 20250906011224_init
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ migration.sql
â”‚Â Â  â”‚Â Â  â””â”€â”€ migration_lock.toml
â”‚Â Â  â”œâ”€â”€ schema.prisma
â”‚Â Â  â””â”€â”€ seed.ts
â”œâ”€â”€ projet_7-9-25-1-9.txt
â”œâ”€â”€ projet_next_a_migrer_en_nuxt.txt
â”œâ”€â”€ projet.txt
â”œâ”€â”€ public
â”‚Â Â  â”œâ”€â”€ favicon.ico
â”‚Â Â  â””â”€â”€ robots.txt
â”œâ”€â”€ README.md
â”œâ”€â”€ server
â”‚Â Â  â”œâ”€â”€ api
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ admin
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ plants
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ [id].ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ users
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ [id].ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ auth
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ login.post.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ logout.post.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ session.get.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ orders
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ [id].ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ plants
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ [id].ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ users
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ [id].ts
â”‚Â Â  â”‚Â Â      â””â”€â”€ index.ts
â”‚Â Â  â””â”€â”€ middleware
â”‚Â Â      â””â”€â”€ auth.global.ts
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tsconfig.seed.json
â””â”€â”€ users.txt

31 directories, 59 files

# CONFIG
#
## package.json

{
	"name": "nuxt-app",
	"type": "module",
	"private": true,
	"scripts": {
		"build": "nuxt build",
		"dev": "nuxt dev",
		"generate": "nuxt generate",
		"preview": "nuxt preview",
		"postinstall": "nuxt prepare"
	},
	"dependencies": {
		"@faker-js/faker": "^10.0.0",
		"@prisma/client": "^6.15.0",
		"bcryptjs": "^3.0.2",
		"next-auth": "^4.24.11",
		"nuxt": "^4.1.1",
		"nuxt-better-auth": "^0.3.1",
		"pg": "^8.16.3",
		"vue": "^3.5.20",
		"vue-router": "^4.5.1"
	},
	"devDependencies": {
		"@types/node": "^24.3.1",
		"cross-env": "^10.0.0",
		"nuxt-auth-utils": "^0.5.24",
		"prisma": "^6.15.0",
		"ts-node": "^10.9.2",
		"tsx": "^4.20.5",
		"typescript": "^5.9.2"
	},
	"prisma": {
		"seed": "tsx prisma/seed.ts"
	}
}


## nuxt.config.ts

export default defineNuxtConfig({
	compatibilityDate: "2025-07-15",
	modules: ["nuxt-auth-utils"],
	devtools: { enabled: true },
	app: {
		head: {
			link: [{ rel: "stylesheet", href: "https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" }],
			script: [{ src: "https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js", tagPosition: "bodyClose" }],
		},
	},
});


## tsconfig.json

{
	"extends": "./.nuxt/tsconfig.json"
}


## .env

# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

# Database Postgre
DB_USER=tilnede0x1182
DB_PASSWORD=tilnede0x1182
DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@localhost:5432/plant_shop_nuxtjs"

# Auth Nuxt (Ã©quivalents NEXTAUTH_*)
NUXT_SESSION_PASSWORD=a6d4f3b2c1hjkhkhkjhjkhe5d7a9f0b1c2d3e4f5061728394a5b6chkjhkjh7d8e9f0011223344556677


## Makefile

# Lancer en mode dÃ©veloppement
run:
	NITRO_PORT=3150 NITRO_PORT=3150 npm run dev

# Builder le projet (production build)
build:
	npm run build

# Lancer en mode production (aprÃ¨s build)
prod:
	NITRO_PORT=3150 npm run start


## prisma/schema.prisma

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             Int      @id @default(autoincrement())
  email          String   @unique
  name           String?
  password       String
  admin          Boolean  @default(false)
  orders         Order[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Plant {
  id          Int         @id @default(autoincrement())
  name        String
  price       Int
  description String?
  stock       Int         @default(0)
  orderItems  OrderItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Order {
  id          Int         @id @default(autoincrement())
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      Int
  totalPrice  Int?
  status      String?
  orderItems  OrderItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model OrderItem {
  id       Int    @id @default(autoincrement())
  orderId  Int
  plantId  Int
  quantity Int
  order    Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  plant    Plant  @relation(fields: [plantId], references: [id], onDelete: Cascade)
}



# TOUS LES FICHIERS PERTINENTS
#
## .env

# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

# Database Postgre
DB_USER=tilnede0x1182
DB_PASSWORD=tilnede0x1182
DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@localhost:5432/plant_shop_nuxtjs"

# Auth Nuxt (Ã©quivalents NEXTAUTH_*)
NUXT_SESSION_PASSWORD=a6d4f3b2c1hjkhkhkjhjkhe5d7a9f0b1c2d3e4f5061728394a5b6chkjhkjh7d8e9f0011223344556677


## tsconfig.json

{
	"extends": "./.nuxt/tsconfig.json"
}


## tsconfig.seed.json

{
	"compilerOptions": {
		"target": "ES2020",
		"module": "ESNext",
		"moduleResolution": "bundler",
		"esModuleInterop": true,
		"strict": true,
		"skipLibCheck": true,
		"types": ["node"]
	},
	"include": ["prisma/**/*.ts"]
}


## import-test.ts

// import-test.ts

// Fonction pour tester les imports
async function testImports() {
	// Option 1 - Imports directs
	try {
		const module1 = await import("nuxt-better-auth");
		console.log("âœ… Option 1 - nuxt-better-auth : OK", Object.keys(module1));
	} catch (e) {
		console.log("âŒ Option 1 - nuxt-better-auth :", e.message);
	}

	// Option 2 - Client via /client
	try {
		const module2 = await import("nuxt-better-auth/client");
		console.log("âœ… Option 2 - nuxt-better-auth/client : OK", Object.keys(module2));
	} catch (e) {
		console.log("âŒ Option 2 - nuxt-better-auth/client :", e.message);
	}

	// Option 3 - Server via /server
	try {
		const module3 = await import("nuxt-better-auth/server");
		console.log("âœ… Option 3 - nuxt-better-auth/server : OK", Object.keys(module3));
	} catch (e) {
		console.log("âŒ Option 3 - nuxt-better-auth/server :", e.message);
	}

	// Option 4 - Via runtime
	try {
		const module4 = await import("nuxt-better-auth/runtime");
		console.log("âœ… Option 4 - nuxt-better-auth/runtime : OK", Object.keys(module4));
	} catch (e) {
		console.log("âŒ Option 4 - nuxt-better-auth/runtime :", e.message);
	}

	// Option 5 - Client via runtime
	try {
		const module5 = await import("nuxt-better-auth/runtime/client");
		console.log("âœ… Option 5 - nuxt-better-auth/runtime/client : OK", Object.keys(module5));
	} catch (e) {
		console.log("âŒ Option 5 - nuxt-better-auth/runtime/client :", e.message);
	}

	// Option 6 - Server via runtime
	try {
		const module6 = await import("nuxt-better-auth/runtime/server");
		console.log("âœ… Option 6 - nuxt-better-auth/runtime/server : OK", Object.keys(module6));
	} catch (e) {
		console.log("âŒ Option 6 - nuxt-better-auth/runtime/server :", e.message);
	}

	// VÃ©rifiez Ã©galement les imports des versions complÃ¨tes (dist)
	try {
		const module7 = await import("nuxt-better-auth/dist/runtime/composables");
		console.log("âœ… Option 7 - nuxt-better-auth/dist/runtime/composables : OK", Object.keys(module7));
	} catch (e) {
		console.log("âŒ Option 7 - nuxt-better-auth/dist/runtime/composables :", e.message);
	}

	try {
		const module8 = await import("nuxt-better-auth/dist/runtime/server");
		console.log("âœ… Option 8 - nuxt-better-auth/dist/runtime/server : OK", Object.keys(module8));
	} catch (e) {
		console.log("âŒ Option 8 - nuxt-better-auth/dist/runtime/server :", e.message);
	}
}

// ExÃ©cuter les tests
testImports();


## components/UserMenu.vue

<script setup lang="ts">
const { loggedIn, user, clear } = useUserSession();

async function logout() {
	await $fetch("/api/auth/logout", { method: "POST" });
	await clear();
	await navigateTo('/')
	if (typeof window !== "undefined") window.location.reload();
}
</script>

<template>
	<div v-if="loggedIn && user" class="dropdown">
		<button class="btn btn-outline-light dropdown-toggle" type="button" data-bs-toggle="dropdown">
			{{ user.name || user.email }}
		</button>
		<ul class="dropdown-menu dropdown-menu-end">
			<li>
				<NuxtLink :to="`/users/${user.id}`" class="dropdown-item">Profil</NuxtLink>
			</li>
			<li>
				<NuxtLink to="/orders" class="dropdown-item">Mes commandes</NuxtLink>
			</li>
			<li v-if="user.admin">
				<NuxtLink to="/admin/plants" class="dropdown-item">Admin Plantes</NuxtLink>
			</li>
			<li v-if="user.admin">
				<NuxtLink to="/admin/users" class="dropdown-item">Admin Utilisateurs</NuxtLink>
			</li>
			<li><hr class="dropdown-divider" /></li>
			<li>
				<button class="dropdown-item text-danger" @click="logout">DÃ©connexion</button>
			</li>
		</ul>
	</div>
</template>


## components/FlashMessages.vue

<script setup lang="ts">
import { ref } from "vue";

const notice = ref("");
const alert = ref("");

// Exemple dâ€™utilisation :
// injectez notice.value = "SuccÃ¨s !" ou alert.value = "Erreur"
</script>

<template>
	<div>
		<div v-if="notice" class="alert alert-success">{{ notice }}</div>
		<div v-if="alert" class="alert alert-danger">{{ alert }}</div>
	</div>
</template>


## components/CartWidget.vue

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'

const count = ref(0)

function loadCartCount() {
	try {
		const cart = JSON.parse(localStorage.getItem('cart') || '{}')
		count.value = Array.isArray(cart)
			? cart.reduce((t, i) => t + (i.quantity || 0), 0)
			: Object.values(cart).reduce((t: number, i: any) => t + (i.quantity || 0), 0)
	} catch {
		count.value = 0
	}
}

// Handler pour l'Ã©vÃ©nement storage pour dÃ©tecter les changements du panier
function handleStorageChange(event: StorageEvent) {
    if (event.key === 'cart') {
        loadCartCount();
    }
}

onMounted(() => {
    loadCartCount();
    window.addEventListener('storage', handleStorageChange);

    // Ã‰couter un Ã©vÃ©nement personnalisÃ© pour les mises Ã  jour du panier
    window.addEventListener('cart-updated', loadCartCount);
});

onUnmounted(() => {
    window.removeEventListener('storage', handleStorageChange);
    window.removeEventListener('cart-updated', loadCartCount);
});
</script>

<template>
	<NuxtLink to="/cart" class="btn btn-outline-light position-relative">
		ğŸ›’
		<span v-if="count > 0" class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger">
			{{ count }}
		</span>
	</NuxtLink>
</template>


## components/Navbar.vue

<script setup lang="ts">
const { loggedIn, user, clear } = useUserSession();

// --- Compteur panier (mÃªme logique que le modÃ¨le Next) ----------------------
import { ref, onMounted, onUnmounted } from "vue";

const cartCount = ref<number>(0);

function updateCartCount() {
	try {
		const raw = localStorage.getItem("cart") || "{}";
		const cart = JSON.parse(raw);
		const total = Array.isArray(cart) ? cart.reduce((t, i) => t + (i.quantity || 0), 0) : Object.values(cart).reduce((t: number, i: any) => t + (i.quantity || 0), 0);
		cartCount.value = total;
	} catch {
		cartCount.value = 0;
	}
}

onMounted(() => {
	updateCartCount();
	window.addEventListener("storage", updateCartCount);
	window.addEventListener("cart-updated", updateCartCount);
});
onUnmounted(() => {
	window.removeEventListener("storage", updateCartCount);
	window.removeEventListener("cart-updated", updateCartCount);
});
// ---------------------------------------------------------------------------

async function logout() {
	await $fetch("/api/auth/logout", { method: "POST" });
	await clear();
	await navigateTo("/");
	if (typeof window !== "undefined") window.location.reload();
}
</script>

<template>
	<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
		<div class="container">
			<NuxtLink class="navbar-brand" to="/">PlantShop</NuxtLink>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
				<span class="navbar-toggler-icon"></span>
			</button>

			<div class="collapse navbar-collapse" id="navbarNav">
				<ul class="navbar-nav ms-auto">
					<li class="nav-item">
						<NuxtLink class="nav-link" to="/cart" id="cart-link">
							Panier<span v-if="cartCount > 0"> ({{ cartCount }})</span>
						</NuxtLink>
					</li>

					<template v-if="loggedIn">
						<li class="nav-item">
							<NuxtLink class="nav-link" to="/orders">Mes Commandes</NuxtLink>
						</li>
						<li class="nav-item">
							<NuxtLink class="nav-link" :to="`/users/${user?.id}`">Mon Profil</NuxtLink>
						</li>
						<li v-if="user?.admin" class="nav-item dropdown">
							<a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">Admin</a>
							<ul class="dropdown-menu">
								<li><NuxtLink class="dropdown-item" to="/admin/plants">Gestion Plantes</NuxtLink></li>
								<li><NuxtLink class="dropdown-item" to="/admin/users">Gestion Utilisateurs</NuxtLink></li>
							</ul>
						</li>
						<li class="nav-item">
							<button class="btn btn-link nav-link" @click="logout">DÃ©connexion</button>
						</li>
					</template>

					<template v-else>
						<li class="nav-item">
							<NuxtLink class="nav-link" to="/auth/signin">Connexion</NuxtLink>
						</li>
						<li class="nav-item">
							<NuxtLink class="nav-link" to="/auth/register">Inscription</NuxtLink>
						</li>
					</template>
				</ul>
			</div>
		</div>
	</nav>
</template>


## prisma/schema.prisma

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             Int      @id @default(autoincrement())
  email          String   @unique
  name           String?
  password       String
  admin          Boolean  @default(false)
  orders         Order[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Plant {
  id          Int         @id @default(autoincrement())
  name        String
  price       Int
  description String?
  stock       Int         @default(0)
  orderItems  OrderItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Order {
  id          Int         @id @default(autoincrement())
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      Int
  totalPrice  Int?
  status      String?
  orderItems  OrderItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model OrderItem {
  id       Int    @id @default(autoincrement())
  orderId  Int
  plantId  Int
  quantity Int
  order    Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  plant    Plant  @relation(fields: [plantId], references: [id], onDelete: Cascade)
}


## prisma/seed.ts

// # Importations
import { PrismaClient, Prisma, User, Plant } from '@prisma/client'
import { faker } from '@faker-js/faker'
import bcrypt from 'bcryptjs'
import { writeFileSync } from 'node:fs'
import { join } from 'node:path'

// # DonnÃ©es
const NB_ADMINS	= 3
const NB_USERS	= 20
const NB_PLANTS	= 30
const MAX_ORDERS_PER_USER = 7
const PLANT_NAMES = [
	'Rose','Tulipe','Lavande','OrchidÃ©e','Basilic','Menthe','Pivoine','Tournesol',
	'Cactus (Echinopsis)','Bambou','Camomille (Matricaria recutita)','Sauge (Salvia officinalis)',
	'Romarin (Rosmarinus officinalis)','Thym (Thymus vulgaris)','Laurier-rose (Nerium oleander)',
	'Aloe vera','Jasmin (Jasminum officinale)','Hortensia (Hydrangea macrophylla)',
	'Marguerite (Leucanthemum vulgare)','GÃ©ranium (Pelargonium graveolens)','Fuchsia (Fuchsia magellanica)',
	'AnÃ©mone (Anemone coronaria)','AzalÃ©e (Rhododendron simsii)','ChrysanthÃ¨me (Chrysanthemum morifolium)',
	'Digitale pourpre (Digitalis purpurea)','GlaÃ¯eul (Gladiolus hortulanus)','Lys (Lilium candidum)',
	'Violette (Viola odorata)','Muguet (Convallaria majalis)','Iris (Iris germanica)',
	'Lavandin (Lavandula intermedia)','Ã‰rable du Japon (Acer palmatum)','Citronnelle (Cymbopogon citratus)',
	'Pin parasol (Pinus pinea)','CyprÃ¨s (Cupressus sempervirens)','Olivier (Olea europaea)',
	'Papyrus (Cyperus papyrus)','Figuier (Ficus carica)','Eucalyptus (Eucalyptus globulus)',
	'Acacia (Acacia dealbata)','BÃ©gonia (Begonia semperflorens)','Calathea (Calathea ornata)',
	'Dieffenbachia (Dieffenbachia seguine)','Ficus elastica','Sansevieria (Sansevieria trifasciata)',
	'Philodendron (Philodendron scandens)','Yucca (Yucca elephantipes)','Zamioculcas zamiifolia',
	'Monstera deliciosa','Pothos (Epipremnum aureum)','Agave (Agave americana)',
	'Cactus raquette (Opuntia ficus-indica)','Palmier-dattier (Phoenix dactylifera)',
	'Amaryllis (Hippeastrum hybridum)','Bleuet (Centaurea cyanus)',
	'CÅ“ur-de-Marie (Lamprocapnos spectabilis)','Croton (Codiaeum variegatum)',
	'Dracaena (Dracaena marginata)','Hosta (Hosta plantaginea)','Lierre (Hedera helix)',
	'Mimosa (Acacia dealbata)'
]

// # Classe SeedService
class SeedService {
	private prisma = new PrismaClient()

	// ## Reset
	private reset = async (): Promise<void> => {
		await this.prisma.orderItem.deleteMany()
		await this.prisma.order.deleteMany()
		await this.prisma.plant.deleteMany()
		await this.prisma.user.deleteMany()
	}

	// ## Admins
	private createAdmins = async () => {
		const admins: { email: string; password: string }[] = []
		for (let idx = 0; idx < NB_ADMINS; idx++) admins.push(await this.addAdmin(idx))
		return admins
	}

	private addAdmin = async (index: number) => {
		const email = `admin${index + 1}@planteshop.com`
		const password = 'password'
		await this.prisma.user.create({
			data: { email, password: await bcrypt.hash(password, 10), admin: true, name: faker.person.fullName() }
		})
		return { email, password }
	}

	// ## Users
	private createUsers = async () => {
		const users: { email: string; password: string }[] = []
		for (let idx = 0; idx < NB_USERS; idx++) users.push(await this.addUser())
		return users
	}

	private addUser = async () => {
		const password = faker.internet.password({ length: 12 })
		const email = faker.internet.email().toLowerCase()
		await this.prisma.user.create({
			data: { email, password: await bcrypt.hash(password, 10), admin: false, name: faker.person.fullName() }
		})
		return { email, password }
	}

	// ## Plants
	private createPlants = async () => {
		const max = PLANT_NAMES.length
		const plants: Plant[] = []
		for (let idx = 0; idx < NB_PLANTS; idx++) plants.push(await this.addPlant(idx, max))
		return plants
	}

	private addPlant = async (idx: number, max: number) => {
		const base = PLANT_NAMES[idx % max]
		const name = NB_PLANTS > max ? `${base} ${Math.floor(idx / max) + 1}` : base
		return this.prisma.plant.create({
			data: {
				name,
				price: faker.number.int({ min: 5, max: 50 }),
				description: faker.lorem.sentence({ min: 10, max: 14 }),
				stock: faker.number.int({ min: 5, max: 30 })
			}
		})
	}

	// ## Orders
	private createOrders = async (plants: Plant[]) => {
		for (const user of await this.prisma.user.findMany()) {
			const numberOfOrders = faker.number.int({ min: 0, max: MAX_ORDERS_PER_USER })
			for (let idx = 0; idx < numberOfOrders; idx++) {
				await this.createOrderForUser(user, plants)
			}
		}
	}

	private createOrderForUser = async (user: User, plants: Plant[]) => {
		let total = 0
		const order = await this.prisma.order.create({
			data: { userId: user.id, totalPrice: 0, status: faker.helpers.arrayElement(['confirmed','pending','shipped','delivered']) }
		})
		for (let iter = 0; iter < 2; iter++) total += await this.addItem(order.id, plants)
		await this.prisma.order.update({ where: { id: order.id }, data: { totalPrice: total } })
	}

	private addItem = async (orderId: number, plants: Plant[]) => {
		const plant = plants[Math.floor(Math.random() * plants.length)]
		if (!plant.stock) return 0
		const qty = Math.min(faker.number.int({ min: 1, max: 5 }), plant.stock)
		if (!qty) return 0
		await this.prisma.orderItem.create({ data: { orderId, plantId: plant.id, quantity: qty } })
		await this.prisma.plant.update({ where: { id: plant.id }, data: { stock: plant.stock - qty } })
		plant.stock -= qty
		return plant.price * qty
	}

	// ## users.txt
	private writeUsersFile = (admins: {email:string;password:string}[], users: {email:string;password:string}[]) => {
		const path = join(process.cwd(), 'users.txt')
		let txt = 'Administrateurs :\n\n'
		admins.forEach(admin => (txt += `${admin.email} ${admin.password}\n`))
		txt += '\nUtilisateurs :\n\n'
		users.forEach(u => (txt += `${u.email} ${u.password}\n`))
		writeFileSync(path, txt, 'utf8')
	}

	// # Main
	public run = async (): Promise<void> => {
		await this.reset()
		const admins = await this.createAdmins()
		const users = await this.createUsers()
		const plants = await this.createPlants()
		this.writeUsersFile(admins, users)
		await this.createOrders(plants)
		console.log('âœ… Seed terminÃ©e. DonnÃ©es crÃ©Ã©es & users.txt gÃ©nÃ©rÃ©.')
		await this.prisma.$disconnect()
	}
}

// # Lancement
new SeedService().run().catch(err => {
	console.error(err)
	process.exit(1)
})


## nuxt.config.ts

export default defineNuxtConfig({
	compatibilityDate: "2025-07-15",
	modules: ["nuxt-auth-utils"],
	devtools: { enabled: true },
	app: {
		head: {
			link: [{ rel: "stylesheet", href: "https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" }],
			script: [{ src: "https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js", tagPosition: "bodyClose" }],
		},
	},
});


## layouts/default.vue

<script setup lang="ts">
</script>

<template>
	<div>
		<!-- Navigation -->
		<Navbar />

		<!-- Messages globaux -->
		<div class="container mt-3">
			<FlashMessages />
		</div>

		<!-- Contenu -->
		<slot />
	</div>
</template>


## pages/admin/plants/[id].vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'


/**
 * DÃ©tail plante cÃ´tÃ© admin
 * Affiche et permet suppression
 * @plant ressource chargÃ©e
 */
const route = useRoute()
const router = useRouter()
const plant = ref<any>(null)

onMounted(async () => {
	plant.value = await $fetch(`/api/plants/${route.params.id}`)
})

async function deletePlant() {
	if (!confirm('Supprimer cette plante ?')) return
	await $fetch(`/api/admin/plants/${route.params.id}`, { method: 'DELETE' })
	router.push('/admin/plants')
}
</script>

<template>
	<div v-if="plant" class="container mt-4">
		<h1>{{ plant.name }}</h1>
		<p><strong>Prix :</strong> {{ plant.price }} â‚¬</p>
		<p><strong>Stock :</strong> {{ plant.stock }}</p>
		<div class="mt-3">
			<NuxtLink :to="`/admin/plants/${plant.id}/edit`" class="btn btn-warning me-2">Modifier</NuxtLink>
			<button class="btn btn-danger" @click="deletePlant">Supprimer</button>
		</div>
	</div>
</template>


## pages/admin/plants/index.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'

type Plant = { id: number; name: string; price: number; stock: number }
const plants = ref<Plant[]>([])

onMounted(async () => {
	plants.value = await $fetch('/api/admin/plants')
})

async function deletePlant(id: number) {
	if (!confirm('Supprimer cette plante ?')) return
	await $fetch(`/api/admin/plants/${id}`, { method: 'DELETE' })
	plants.value = plants.value.filter(p => p.id !== id)
}
</script>

<template>
	<div class="container mt-4">
		<h1>Gestion des Plantes (Admin)</h1>
		<NuxtLink to="/admin/plants/new" class="btn btn-success mb-3">Nouvelle Plante</NuxtLink>
		<table class="table table-striped">
			<thead class="table-light">
				<tr><th>Nom</th><th>Prix</th><th>Stock</th><th>Actions</th></tr>
			</thead>
			<tbody>
				<tr v-for="plant in plants" :key="plant.id">
					<td><NuxtLink :to="`/plants/${plant.id}`">{{ plant.name }}</NuxtLink></td>
					<td>{{ plant.price }} â‚¬</td>
					<td>{{ plant.stock }}</td>
					<td>
						<NuxtLink :to="`/admin/plants/${plant.id}/edit`" class="btn btn-warning btn-sm me-2">âœ Modifier</NuxtLink>
						<button class="btn btn-danger btn-sm" @click="deletePlant(plant.id)">ğŸ—‘ Supprimer</button>
					</td>
				</tr>
			</tbody>
		</table>
	</div>
</template>


## pages/admin/plants/new.vue

<script setup lang="ts">
import { ref } from 'vue'
import { useRoute, useRouter } from '#app'


/**
 * Formulaire crÃ©ation plante (admin)
 * Valide la SFC et crÃ©e une plante
 * @form donnÃ©es du formulaire
 */
const router = useRouter()
const form = ref({ name: '', price: 0, description: '', stock: 0 })

async function handleSubmit() {
	await $fetch('/api/plants', { method: 'POST', body: form.value })
	router.push('/admin/plants')
}
</script>

<template>
	<div class="container mt-4">
		<h1>Nouvelle Plante ğŸŒ±</h1>
		<form @submit.prevent="handleSubmit">
			<div class="mb-3"><label>Nom</label><input v-model="form.name" class="form-control" required /></div>
			<div class="mb-3"><label>Prix (â‚¬)</label><input v-model="form.price" type="number" class="form-control" required /></div>
			<div class="mb-3"><label>Description</label><textarea v-model="form.description" class="form-control" rows="4"></textarea></div>
			<div class="mb-3"><label>Stock</label><input v-model="form.stock" type="number" class="form-control" required /></div>
			<button class="btn btn-success">CrÃ©er</button>
		</form>
	</div>
</template>


## pages/admin/plants/[id]/edit.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'


const route = useRoute()
const router = useRouter()
const form = ref({ name: '', price: 0, description: '', stock: 0 })

onMounted(async () => {
	const data = await $fetch(`/api/plants/${route.params.id}`)
	form.value = data
})

async function handleSubmit() {
	await $fetch(`/api/plants/${route.params.id}`, { method: 'PUT', body: form.value })
	router.push('/admin/plants')
}
</script>

<template>
	<div class="container mt-4">
		<h1>Modifier la Plante</h1>
		<form @submit.prevent="handleSubmit">
			<div class="mb-3"><label>Nom</label><input v-model="form.name" class="form-control" required /></div>
			<div class="mb-3"><label>Prix (â‚¬)</label><input v-model="form.price" type="number" class="form-control" required /></div>
			<div class="mb-3"><label>Description</label><textarea v-model="form.description" class="form-control"></textarea></div>
			<div class="mb-3"><label>Stock</label><input v-model="form.stock" type="number" class="form-control" required /></div>
			<button class="btn btn-primary">Enregistrer</button>
		</form>
	</div>
</template>


## pages/admin/users/[id].vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute } from 'vue-router'

const route = useRoute()
const user = ref<any>(null)

onMounted(async () => {
	user.value = await $fetch(`/api/users/${route.params.id}`)
})
</script>

<template>
	<div v-if="user" class="container mt-4">
		<h1>DÃ©tails Utilisateur</h1>
		<p><strong>Email :</strong> {{ user.email }}</p>
		<p><strong>Nom :</strong> {{ user.name || '-' }}</p>
		<p><strong>Administrateur :</strong> {{ user.admin ? 'Oui' : 'Non' }}</p>
		<NuxtLink :to="`/admin/users/${user.id}/edit`" class="btn btn-warning mt-3">Modifier</NuxtLink>
	</div>
</template>


## pages/admin/users/index.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'

type User = { id: number; email: string; name?: string; admin: boolean }
const users = ref<User[]>([])

onMounted(async () => {
	users.value = await $fetch('/api/users')
})
</script>

<template>
	<div class="container mt-4">
		<h1>Gestion des Utilisateurs</h1>
		<table class="table table-striped mt-3">
			<thead class="table-light">
				<tr><th>Nom</th><th>Email</th><th>Admin</th><th>Actions</th></tr>
			</thead>
			<tbody>
				<tr v-for="user in users" :key="user.id">
					<td><NuxtLink :to="`/admin/users/${user.id}`">{{ user.name || '-' }}</NuxtLink></td>
					<td>{{ user.email }}</td>
					<td>
						<span :class="['badge', user.admin ? 'bg-success' : 'bg-secondary']">
							{{ user.admin ? 'Oui' : 'Non' }}
						</span>
					</td>
					<td>
						<NuxtLink :to="`/admin/users/${user.id}/edit`" class="btn btn-warning btn-sm">âœ Modifier</NuxtLink>
					</td>
				</tr>
			</tbody>
		</table>
	</div>
</template>


## pages/admin/users/[id]/edit.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'


const route = useRoute()
const router = useRouter()
const form = ref({ email: '', name: '', admin: false })

onMounted(async () => {
	const data = await $fetch(`/api/users/${route.params.id}`)
	form.value = { email: data.email, name: data.name, admin: data.admin }
})

async function handleSubmit() {
	await $fetch(`/api/users/${route.params.id}`, { method: 'PUT', body: form.value })
	router.push(`/admin/users/${route.params.id}`)
}
</script>

<template>
	<div class="container mt-4">
		<h1>Modifier Utilisateur</h1>
		<form @submit.prevent="handleSubmit">
			<div class="mb-3">
				<label>Email</label>
				<input v-model="form.email" type="email" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Nom</label>
				<input v-model="form.name" type="text" class="form-control" />
			</div>
			<div class="mb-3 form-check">
				<input v-model="form.admin" type="checkbox" class="form-check-input" id="adminCheck" />
				<label for="adminCheck" class="form-check-label">Administrateur</label>
			</div>
			<button class="btn btn-primary">Enregistrer</button>
		</form>
	</div>
</template>


## pages/plants/[id].vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'

const route = useRoute()
const router = useRouter()
const plant = ref<any>(null)

const { user, loggedIn } = useUserSession()
const isAdmin = computed(() => !!(loggedIn.value && user.value?.admin))

onMounted(async () => {
  plant.value = await $fetch(`/api/plants/${route.params.id}`)
})

async function deletePlant() {
  if (!plant.value) return
  if (!confirm('Supprimer cette plante ?')) return
  await $fetch(`/api/admin/plants/${route.params.id}`, { method: 'DELETE' })
  router.push('/plants')
}

function addToCart() {
  if (!plant.value) return

  let cart: Record<number, any>
  try {
    cart = JSON.parse(localStorage.getItem('cart') || '{}')
  } catch {
    cart = {}
  }

  const id = plant.value.id
  cart[id] = cart[id]
    ? { ...cart[id], quantity: cart[id].quantity + 1 }
    : { id: plant.value.id, name: plant.value.name, price: plant.value.price, quantity: 1 }

  localStorage.setItem('cart', JSON.stringify(cart))
  window.dispatchEvent(new Event('cart-updated'))
}
</script>

<template>
  <div v-if="plant" class="container mt-4">
    <h1>{{ plant.name }}</h1>
    <p><strong>Prix :</strong> {{ plant.price }} â‚¬</p>
    <p><strong>Description :</strong> {{ plant.description }}</p>
    <p v-if="isAdmin"><strong>Stock :</strong> {{ plant.stock }}</p>

    <div class="mt-3">
      <button class="btn btn-success me-2" @click="addToCart">Ajouter au panier</button>
      <NuxtLink v-if="isAdmin" :to="`/plants/${plant.id}/edit`" class="btn btn-warning me-2">Modifier</NuxtLink>
      <button v-if="isAdmin" class="btn btn-danger" @click="deletePlant">Supprimer</button>
    </div>
  </div>
</template>


## pages/plants/index.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'

type Plant = { id: number; name: string; price: number; stock: number }

const plants = ref<Plant[]>([])
const { user, loggedIn } = useUserSession()
const isAdmin = computed(() => !!(loggedIn.value && user.value?.admin))

onMounted(async () => {
  plants.value = await $fetch('/api/plants')
})
</script>

<template>
  <div class="container mt-4">
    <h1 class="mb-4">Liste des Plantes</h1>
    <NuxtLink v-if="isAdmin" to="/admin/plants/new" class="btn btn-success mb-3">
      Nouvelle Plante
    </NuxtLink>
    <div class="row">
      <div v-for="plant in plants" :key="plant.id" class="col-md-4">
        <div class="card mb-3 shadow-sm">
          <div class="card-body">
            <h5 class="card-title">
              <NuxtLink :to="`/plants/${plant.id}`" class="text-decoration-none text-dark">
                {{ plant.name }}
              </NuxtLink>
            </h5>
            <p><strong>Prix :</strong> {{ plant.price }} â‚¬</p>
            <p v-if="isAdmin"><strong>Stock :</strong> {{ plant.stock }}</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>


## pages/plants/new.vue

<script setup lang="ts">
import { ref } from 'vue'
import { useRoute, useRouter } from '#app'


const router = useRouter()
const form = ref({ name: '', price: 0, description: '', stock: 0 })

async function handleSubmit() {
	await $fetch('/api/plants', { method: 'POST', body: form.value })
	router.push('/plants')
}
</script>

<template>
	<div class="container mt-4">
		<h1>Nouvelle Plante ğŸŒ±</h1>
		<form @submit.prevent="handleSubmit">
			<div class="mb-3">
				<label>Nom</label>
				<input v-model="form.name" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Prix (â‚¬)</label>
				<input v-model="form.price" type="number" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Description</label>
				<textarea v-model="form.description" class="form-control" rows="4"></textarea>
			</div>
			<div class="mb-3">
				<label>Stock</label>
				<input v-model="form.stock" type="number" class="form-control" required />
			</div>
			<button class="btn btn-success">CrÃ©er</button>
		</form>
	</div>
</template>


## pages/plants/[id]/edit.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'


const route = useRoute()
const router = useRouter()
const form = ref({ name: '', price: 0, description: '', stock: 0 })

onMounted(async () => {
	const data = await $fetch(`/api/plants/${route.params.id}`)
	form.value = data
})

async function handleSubmit() {
	await $fetch(`/api/plants/${route.params.id}`, {
		method: 'PUT',
		body: form.value
	})
	router.push(`/plants/${route.params.id}`)
}
</script>

<template>
	<div class="container mt-4">
		<h1>Ã‰diter la Plante</h1>
		<form @submit.prevent="handleSubmit">
			<div class="mb-3">
				<label>Nom</label>
				<input v-model="form.name" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Prix (â‚¬)</label>
				<input v-model="form.price" type="number" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Description</label>
				<textarea v-model="form.description" class="form-control" rows="4"></textarea>
			</div>
			<div class="mb-3">
				<label>Stock</label>
				<input v-model="form.stock" type="number" class="form-control" required />
			</div>
			<button class="btn btn-primary">Enregistrer</button>
		</form>
	</div>
</template>


## pages/orders/index.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'

type OrderItem = { id: number; quantity: number; plant: { id: number; name: string; price: number } }
type Order = { id: number; createdAt: string; totalPrice: number; status: string; orderItems: OrderItem[] }

const orders = ref<Order[]>([])

onMounted(async () => {
	orders.value = await $fetch('/api/orders').catch(() => [])
})
</script>

<template>
	<div class="container mt-4">
		<h1>ğŸ“œ Mes Commandes</h1>
		<div v-if="!orders.length" class="alert alert-info mt-3">
			Aucune commande pour le moment.
		</div>
		<div v-for="(order, index) in orders" :key="order.id" class="card mb-3 shadow-sm">
			<div class="card-body">
				<h5 class="card-title">Commande nÂ°{{ orders.length - index }}</h5>
				<p class="text-muted">PassÃ©e le {{ new Date(order.createdAt).toLocaleString() }}</p>
				<ul>
					<li v-for="item in order.orderItems" :key="item.id">
						<NuxtLink :to="`/plants/${item.plant.id}`">{{ item.plant.name }}</NuxtLink>
						â€“ {{ item.quantity }} Ã— {{ item.plant.price }} â‚¬
					</li>
				</ul>
				<p><strong>Total :</strong> {{ order.totalPrice }} â‚¬</p>
				<p><strong>Statut :</strong> {{ order.status }}</p>
			</div>
		</div>
	</div>
</template>


## pages/orders/new.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRouter } from '#app'

type CartItem = { id: number; name: string; price: number; quantity: number }
const cartItems = ref<CartItem[]>([])
const error = ref('')
const router = useRouter()

const { loggedIn } = useUserSession()

onMounted(() => {
  const stored = localStorage.getItem('cart')
  if (!stored) return
  let parsed = JSON.parse(stored)
  if (!Array.isArray(parsed) && typeof parsed === 'object') parsed = Object.values(parsed)
  cartItems.value = parsed
})

async function confirmOrder() {
  if (!loggedIn.value) {
    error.value = 'Utilisateur non connectÃ©.'
    return
  }
  const res = await $fetch('/api/orders', {
    method: 'POST',
    body: { items: cartItems.value.map(i => ({ plant_id: i.id, quantity: i.quantity })) }
  }).catch(err => ({ error: err?.data?.message || err?.message }))
  if ((res as any)?.error) {
    error.value = (res as any).error || 'Erreur commande'
    return
  }
  localStorage.removeItem('cart')
  window.dispatchEvent(new Event('cart-updated'))
  router.push('/orders')
}
</script>

<template>
  <div class="container mt-4">
    <h1>Valider ma commande</h1>
    <div v-if="error" class="alert alert-danger">{{ error }}</div>
    <div v-if="!cartItems.length" class="alert alert-info">Votre panier est vide.</div>
    <div v-else>
      <table class="table shadow">
        <thead class="table-light">
          <tr><th>Plante</th><th>QuantitÃ©</th><th>Total</th></tr>
        </thead>
        <tbody>
          <tr v-for="item in cartItems" :key="item.id">
            <td><NuxtLink :to="`/plants/${item.id}`">{{ item.name }}</NuxtLink></td>
            <td>{{ item.quantity }}</td>
            <td>{{ item.price * item.quantity }} â‚¬</td>
          </tr>
        </tbody>
      </table>
      <p class="fw-bold text-end">Total : {{ cartItems.reduce((t,i)=>t + i.price*i.quantity, 0) }} â‚¬</p>
      <button class="btn btn-success w-100" @click="confirmOrder">Confirmer la commande</button>
    </div>
  </div>
</template>


## pages/bootstrap-check.vue

<template>
  <div class="container py-4">
    <h1 class="mb-3">VÃ©rif Bootstrap</h1>
    <p>
      <button class="btn btn-primary" type="button" data-bs-toggle="collapse" data-bs-target="#demo">
        Bouton Bootstrap
      </button>
    </p>
    <div id="demo" class="collapse">
      <div class="alert alert-success mb-0">OK : CSS + JS actives.</div>
    </div>
  </div>
</template>


## pages/index.vue

<script setup lang="ts">
/**
 * Accueil : redirige vers le catalogue
 * Simplifie la navigation depuis "/"
 */
await navigateTo('/plants')
</script>

<template></template>


## pages/cart.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'

type CartItem = { id: number; name: string; price: number; quantity: number; stock: number }
const cart = ref<Record<number, CartItem>>({})

function loadCart() {
	try {
		return JSON.parse(localStorage.getItem('cart') || '{}')
	} catch {
		return {}
	}
}

function saveCart(c: Record<number, CartItem>) {
	localStorage.setItem('cart', JSON.stringify(c))
	cart.value = c
}

function removeItem(id: number) {
	const c = { ...cart.value }
	delete c[id]
	saveCart(c)
}

onMounted(() => {
	cart.value = loadCart()
})
</script>

<template>
	<div class="container mt-4">
		<h1>ğŸ›’ Mon Panier</h1>
		<div v-if="!Object.keys(cart).length" class="alert alert-info mt-3">
			Votre panier est vide.
		</div>
		<table v-else class="table mt-3">
			<thead class="table-light">
				<tr>
					<th>Plante</th>
					<th>QuantitÃ©</th>
					<th>Total</th>
					<th></th>
				</tr>
			</thead>
			<tbody>
				<tr v-for="item in cart" :key="item.id">
					<td>{{ item.name }}</td>
					<td>{{ item.quantity }}</td>
					<td>{{ item.price * item.quantity }} â‚¬</td>
					<td>
						<button class="btn btn-danger btn-sm" @click="removeItem(item.id)">Retirer</button>
					</td>
				</tr>
			</tbody>
		</table>
		<div v-if="Object.keys(cart).length" class="mt-3 text-end">
			<NuxtLink to="/orders/new" class="btn btn-primary">Passer la commande</NuxtLink>
		</div>
	</div>
</template>


## pages/auth/unauthorized.vue

<template>
	<div class="container mt-4">
		<div class="alert alert-danger">
			ğŸš« AccÃ¨s refusÃ©. Vous nâ€™avez pas les droits suffisants.
		</div>
		<NuxtLink to="/" class="btn btn-primary mt-3">Retour Ã  lâ€™accueil</NuxtLink>
	</div>
</template>


## pages/auth/signin.vue

<script setup lang="ts">
import { ref } from "vue";

const email = ref("");
const password = ref("");
const error = ref("");

async function handleLogin() {
	try {
		const res = await $fetch("/api/auth/login", {
			method: "POST",
			body: { email: email.value, password: password.value },
		});
		if (res?.ok) {
			await navigateTo('/')
			if (typeof window !== "undefined") window.location.reload();
		} else {
			error.value = "Email ou mot de passe invalide";
		}
	} catch {
		error.value = "Email ou mot de passe invalide";
	}
}
</script>

<template>
	<div class="container mt-4">
		<h1>Se connecter</h1>
		<form @submit.prevent="handleLogin" class="mt-3" style="max-width: 400px">
			<div class="mb-3">
				<label>Email</label>
				<input v-model="email" type="email" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Mot de passe</label>
				<input v-model="password" type="password" class="form-control" required />
			</div>
			<div v-if="error" class="alert alert-danger">{{ error }}</div>
			<button class="btn btn-primary w-100" type="submit">Connexion</button>
		</form>
	</div>
</template>


## pages/auth/register.vue

<script setup lang="ts">
import { ref } from 'vue'

const email = ref('')
const name = ref('')
const password = ref('')
const passwordConfirmation = ref('')
const error = ref('')

async function handleRegister() {
	if (password.value !== passwordConfirmation.value) {
		error.value = 'Les mots de passe ne correspondent pas'
		return
	}
	const res = await $fetch('/api/users', {
		method: 'POST',
		body: { email: email.value, name: name.value, password: password.value }
	})
	if ('error' in res) {
		error.value = (res as any).error
	} else {
		await navigateTo('/auth/signin')
	}
}
</script>

<template>
	<div class="container mt-4">
		<h1>Inscription</h1>
		<form @submit.prevent="handleRegister" class="mt-3" style="max-width:500px">
			<div class="mb-3">
				<label>Email</label>
				<input v-model="email" type="email" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Nom</label>
				<input v-model="name" type="text" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Mot de passe</label>
				<input v-model="password" type="password" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Confirmation mot de passe</label>
				<input v-model="passwordConfirmation" type="password" class="form-control" required />
			</div>
			<div v-if="error" class="alert alert-danger">{{ error }}</div>
			<button class="btn btn-success w-100" type="submit">CrÃ©er un compte</button>
		</form>
	</div>
</template>


## pages/users/[id].vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute } from 'vue-router'

const route = useRoute()
const user = ref<any>(null)

onMounted(async () => {
	user.value = await $fetch(`/api/users/${route.params.id}`)
})
</script>

<template>
	<div class="container mt-4" v-if="user">
		<h1>Mon Profil</h1>
		<p><strong>Email :</strong> {{ user.email }}</p>
		<p v-if="user.name"><strong>Nom :</strong> {{ user.name }}</p>
		<NuxtLink :to="`/users/${user.id}/edit`" class="btn btn-primary">
			Modifier mon profil
		</NuxtLink>
	</div>
</template>


## pages/users/[id]/edit.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'


const route = useRoute()
const router = useRouter()
const form = ref({ email: '', name: '' })
const errors = ref<string[]>([])
const loading = ref(true)

onMounted(async () => {
	const data = await $fetch(`/api/users/${route.params.id}`)
	form.value = { email: data.email || '', name: data.name || '' }
	loading.value = false
})

async function handleSubmit() {
	const res = await $fetch(`/api/users/${route.params.id}`, {
		method: 'PUT',
		body: form.value
	}).catch(async (err) => {
		errors.value = [err.message]
	})
	if (!errors.value.length) router.push(`/users/${route.params.id}`)
}
</script>

<template>
	<div class="container mt-4">
		<h1>Modifier mon profil</h1>
		<p v-if="loading">Chargement...</p>
		<form v-else @submit.prevent="handleSubmit">
			<div class="mb-3">
				<label>Email</label>
				<input v-model="form.email" type="email" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Nom</label>
				<input v-model="form.name" type="text" class="form-control" />
			</div>
			<div v-if="errors.length" class="alert alert-danger">
				<ul><li v-for="(err,idx) in errors" :key="idx">{{ err }}</li></ul>
			</div>
			<button class="btn btn-primary">Enregistrer</button>
		</form>
	</div>
</template>


## composables/useCart.ts

// composables/useCart.ts
/**
 * Ajout d'une plante au panier localStorage + Ã©vÃ¨nement cart-updated.
 * @param plant objet plante (id, name, price, ...)
 */
export function addToCart(plant: { id: number; name: string; price: number }) {
	let cart: Record<number, any>;
	try {
		cart = JSON.parse(localStorage.getItem("cart") || "{}");
	} catch {
		cart = {};
	}
	const id = plant.id;
	cart[id] = cart[id] ? { ...cart[id], quantity: cart[id].quantity + 1 } : { id: plant.id, name: plant.name, price: plant.price, quantity: 1 };
	localStorage.setItem("cart", JSON.stringify(cart));
	window.dispatchEvent(new Event("cart-updated"));
}


## README.md

# Nuxt Minimal Starter

Look at the [Nuxt documentation](https://nuxt.com/docs/getting-started/introduction) to learn more.

## Setup

Make sure to install dependencies:

```bash
# npm
npm install

# pnpm
pnpm install

# yarn
yarn install

# bun
bun install
```

## Development Server

Start the development server on `http://localhost:3000`:

```bash
# npm
npm run dev

# pnpm
pnpm dev

# yarn
yarn dev

# bun
bun run dev
```

## Production

Build the application for production:

```bash
# npm
npm run build

# pnpm
pnpm build

# yarn
yarn build

# bun
bun run build
```

Locally preview production build:

```bash
# npm
npm run preview

# pnpm
pnpm preview

# yarn
yarn preview

# bun
bun run preview
```

Check out the [deployment documentation](https://nuxt.com/docs/getting-started/deployment) for more information.


## app.vue

<template>
	<NuxtLayout>
		<NuxtPage />
	</NuxtLayout>
</template>


## server/api/admin/plants/[id].ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, sendError, createError } from "h3";

// # DonnÃ©es
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	const id = Number(event.context.params?.id);
	if (isNaN(id)) return sendError(event, createError({ statusCode: 400, statusMessage: "Invalid ID" }));

	if (event.node.req.method === "DELETE") {
		await prisma.plant.delete({ where: { id } });
		return { message: "Plant deleted" };
	}
});


## server/api/admin/plants/index.ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler } from "h3";

// # DonnÃ©es
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async () => {
	// Liste complÃ¨te des plantes (admin)
	return await prisma.plant.findMany({
		orderBy: { name: "asc" },
	});
});


## server/api/admin/users/[id].ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, sendError, createError } from "h3";

// # DonnÃ©es
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	const id = Number(event.context.params?.id);
	if (isNaN(id)) return sendError(event, createError({ statusCode: 400, statusMessage: "Invalid ID" }));

	if (event.node.req.method === "DELETE") {
		await prisma.user.delete({ where: { id } });
		return { message: "User deleted" };
	}
});


## server/api/plants/[id].ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody, sendError, createError } from "h3";

// # DonnÃ©es
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	const id = Number(event.context.params?.id);
	if (isNaN(id)) return sendError(event, createError({ statusCode: 400, statusMessage: "Invalid ID" }));

	if (event.node.req.method === "GET") {
		const plant = await prisma.plant.findUnique({ where: { id } });
		if (!plant) return sendError(event, createError({ statusCode: 404, statusMessage: "Plant not found" }));
		return plant;
	}

	if (event.node.req.method === "PUT") {
		const data = await readBody(event);
		return await prisma.plant.update({ where: { id }, data });
	}

	if (event.node.req.method === "DELETE") {
		await prisma.plant.delete({ where: { id } });
		return { message: "Plant deleted" };
	}
});


## server/api/plants/index.ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody } from "h3";

// # DonnÃ©es
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	if (event.node.req.method === "GET") {
		// Liste des plantes en stock
		return await prisma.plant.findMany({
			where: { stock: { gte: 1 } },
			orderBy: { name: "asc" },
		});
	}

	if (event.node.req.method === "POST") {
		// CrÃ©ation dâ€™une plante
		const data = await readBody(event);
		return await prisma.plant.create({ data });
	}
});


## server/api/orders/[id].ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody, sendError, createError } from "h3";

// # DonnÃ©es
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	const id = Number(event.context.params?.id);
	if (isNaN(id)) return sendError(event, createError({ statusCode: 400, statusMessage: "Invalid ID" }));

	if (event.node.req.method === "GET") {
		const order = await prisma.order.findUnique({
			where: { id },
			include: { orderItems: true },
		});
		if (!order) return sendError(event, createError({ statusCode: 404, statusMessage: "Order not found" }));
		return order;
	}

	if (event.node.req.method === "PUT") {
		const data = await readBody(event);
		return await prisma.order.update({ where: { id }, data });
	}

	if (event.node.req.method === "DELETE") {
		await prisma.order.delete({ where: { id } });
		return { message: "Order deleted" };
	}
});


## server/api/orders/index.ts

import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody, sendError, createError } from "h3";
// import { requireUserSession } from "nuxt-auth-utils";

const prisma = new PrismaClient();

export default defineEventHandler(async (event) => {
	if (event.node.req.method === "GET") {
		const { user } = await requireUserSession(event);
		const userId = Number(user.id);

		return prisma.order.findMany({
			where: { userId },
			include: { orderItems: { include: { plant: true } } },
		});
	}

	if (event.node.req.method === "POST") {
		const { user } = await requireUserSession(event);
		const userId = Number(user.id);

		const { items } = await readBody<{ items: { plant_id: number; quantity: number }[] }>(event);
		if (!Array.isArray(items) || !items.length) {
			return sendError(event, createError({ statusCode: 400, statusMessage: "DonnÃ©es invalides" }));
		}

		let total = 0;
		const order = await prisma.order.create({ data: { userId, status: "confirmed", totalPrice: 0 } });
		for (const item of items) {
			const plant = await prisma.plant.findUnique({ where: { id: item.plant_id } });
			if (!plant || plant.stock < item.quantity) {
				return sendError(event, createError({ statusCode: 400, statusMessage: `Stock insuffisant pour ${item.plant_id}` }));
			}
			total += plant.price * item.quantity;
			await prisma.plant.update({ where: { id: plant.id }, data: { stock: plant.stock - item.quantity } });
			await prisma.orderItem.create({ data: { orderId: order.id, plantId: plant.id, quantity: item.quantity } });
		}
		return prisma.order.update({ where: { id: order.id }, data: { totalPrice: total } });
	}
});


## server/api/auth/login.post.ts

import { defineEventHandler, readBody, createError } from "h3";
// import { setUserSession } from "nuxt-auth-utils";
import { PrismaClient } from "@prisma/client";
import bcrypt from "bcryptjs";

const prisma = new PrismaClient();

export default defineEventHandler(async (event) => {
	const { email, password } = await readBody<{ email: string; password: string }>(event);
	if (!email || !password) throw createError({ statusCode: 400, statusMessage: "DonnÃ©es invalides" });

	const user = await prisma.user.findUnique({ where: { email } });
	if (!user || !(await bcrypt.compare(password, user.password))) {
		throw createError({ statusCode: 401, statusMessage: "Identifiants invalides" });
	}

	await setUserSession(event, {
		user: { id: String(user.id), email: user.email, name: user.name ?? null, admin: user.admin },
		loggedInAt: new Date(),
	});
	return { ok: true };
});


## server/api/auth/logout.post.ts

import { defineEventHandler } from "h3";
// import { clearUserSession } from "nuxt-auth-utils";

export default defineEventHandler(async (event) => {
	await clearUserSession(event);
	return { ok: true };
});


## server/api/auth/session.get.ts

import { defineEventHandler } from "h3";
// import { getUserSession } from "nuxt-auth-utils";

export default defineEventHandler(async (event) => {
	return await getUserSession(event); // { user, loggedInAt, ... } ou null
});


## server/api/users/[id].ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody, sendError, createError } from "h3";

// # DonnÃ©es
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	const id = Number(event.context.params?.id);
	if (isNaN(id)) return sendError(event, createError({ statusCode: 400, statusMessage: "Invalid ID" }));

	if (event.node.req.method === "GET") {
		const user = await prisma.user.findUnique({ where: { id } });
		if (!user) return sendError(event, createError({ statusCode: 404, statusMessage: "User not found" }));
		return user;
	}

	if (event.node.req.method === "PUT") {
		const data = await readBody(event);
		return await prisma.user.update({ where: { id }, data });
	}

	if (event.node.req.method === "DELETE") {
		await prisma.user.delete({ where: { id } });
		return { message: "User deleted" };
	}
});


## server/api/users/index.ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody, sendError, createError } from "h3";
import bcrypt from "bcryptjs";

// # DonnÃ©es
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	if (event.node.req.method === "GET") {
		return await prisma.user.findMany({
			orderBy: [{ admin: "desc" }, { name: "asc" }],
		});
	}

	if (event.node.req.method === "POST") {
		const data = await readBody(event);
		try {
			const hashedPassword = await bcrypt.hash(data.password, 10);
			return await prisma.user.create({
				data: {
					email: data.email,
					name: data.name,
					password: hashedPassword,
				},
			});
		} catch (err: any) {
			if (err.code === "P2002") {
				return sendError(event, createError({ statusCode: 400, statusMessage: "Cet email existe dÃ©jÃ ." }));
			}
			return sendError(event, createError({ statusCode: 500, statusMessage: "Erreur crÃ©ation utilisateur." }));
		}
	}
});


## server/middleware/auth.global.ts

import { defineEventHandler, sendRedirect } from "h3";
// import { requireUserSession } from "nuxt-auth-utils";

export default defineEventHandler(async (event) => {
	const url = new URL(event.node.req.url || "/", `http://${event.node.req.headers.host || "localhost"}`);
	const { pathname } = url;

	// ProtÃ©ger toute la zone admin (pages + API)
	if (pathname.startsWith("/admin") || pathname.startsWith("/api/admin")) {
		const { user } = await requireUserSession(event); // 401 si non connectÃ©
		if (!user?.admin) return sendRedirect(event, "/auth/unauthorized", 302);
	}
});


## package.json

{
	"name": "nuxt-app",
	"type": "module",
	"private": true,
	"scripts": {
		"build": "nuxt build",
		"dev": "nuxt dev",
		"generate": "nuxt generate",
		"preview": "nuxt preview",
		"postinstall": "nuxt prepare"
	},
	"dependencies": {
		"@faker-js/faker": "^10.0.0",
		"@prisma/client": "^6.15.0",
		"bcryptjs": "^3.0.2",
		"next-auth": "^4.24.11",
		"nuxt": "^4.1.1",
		"nuxt-better-auth": "^0.3.1",
		"pg": "^8.16.3",
		"vue": "^3.5.20",
		"vue-router": "^4.5.1"
	},
	"devDependencies": {
		"@types/node": "^24.3.1",
		"cross-env": "^10.0.0",
		"nuxt-auth-utils": "^0.5.24",
		"prisma": "^6.15.0",
		"ts-node": "^10.9.2",
		"tsx": "^4.20.5",
		"typescript": "^5.9.2"
	},
	"prisma": {
		"seed": "tsx prisma/seed.ts"
	}
}



# Liste des parties
#
      1 ## app.vue
      4 ## components
      1 ## composables
      1 ## Development Server
      2 ## .env
      1 ## import-test.ts
      1 ## layouts
      1 ## Makefile
      2 ## nuxt.config.ts
      2 ## package.json
     21 ## pages
      3 ## prisma
      1 ## Production
      1 ## README.md
     13 ## server
      1 ## Setup
      2 ## tsconfig.json
      1 ## tsconfig.seed.json
