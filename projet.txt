
# ARBORESCENCE
#
/home/tilnede0x1182/code/tilnede0x1182/Personnel/2025/Entrainement/plant_shop/Javascript/NuxtJS/plant_shop_nuxtjs
├── app
├── app.html
├── app.vue
├── components
│   ├── CartWidget.vue
│   ├── FlashMessages.vue
│   ├── Navbar.vue
│   └── UserMenu.vue
├── composables
│   └── useCart.ts
├── import-test.ts
├── layouts
│   └── default.vue
├── Makefile
├── nuxt.config.ts
├── package.json
├── pages
│   ├── admin
│   │   ├── plants
│   │   │   ├── [id]
│   │   │   │   └── edit.vue
│   │   │   ├── [id].vue
│   │   │   ├── index.vue
│   │   │   └── new.vue
│   │   └── users
│   │       ├── [id]
│   │       │   └── edit.vue
│   │       ├── [id].vue
│   │       └── index.vue
│   ├── auth
│   │   ├── register.vue
│   │   ├── signin.vue
│   │   └── unauthorized.vue
│   ├── bootstrap-check.vue
│   ├── cart.vue
│   ├── index.vue
│   ├── orders
│   │   ├── index.vue
│   │   └── new.vue
│   ├── plants
│   │   ├── [id]
│   │   │   └── edit.vue
│   │   ├── [id].vue
│   │   ├── index.vue
│   │   └── new.vue
│   └── users
│       ├── [id]
│       │   └── edit.vue
│       └── [id].vue
├── prisma
│   ├── migrations
│   │   ├── 20250906011224_init
│   │   │   └── migration.sql
│   │   └── migration_lock.toml
│   ├── schema.prisma
│   └── seed.ts
├── projet_7-9-25-1-9.txt
├── projet_next_a_migrer_en_nuxt.txt
├── projet.txt
├── public
│   ├── favicon.ico
│   └── robots.txt
├── README.md
├── server
│   ├── api
│   │   ├── admin
│   │   │   ├── plants
│   │   │   │   ├── [id].ts
│   │   │   │   └── index.ts
│   │   │   └── users
│   │   │       └── [id].ts
│   │   ├── auth
│   │   │   ├── login.post.ts
│   │   │   ├── logout.post.ts
│   │   │   └── session.get.ts
│   │   ├── orders
│   │   │   ├── [id].ts
│   │   │   └── index.ts
│   │   ├── plants
│   │   │   ├── [id].ts
│   │   │   └── index.ts
│   │   └── users
│   │       ├── [id].ts
│   │       └── index.ts
│   └── middleware
│       └── auth.global.ts
├── tsconfig.json
├── tsconfig.seed.json
└── users.txt

31 directories, 59 files

# CONFIG
#
## package.json

{
	"name": "nuxt-app",
	"type": "module",
	"private": true,
	"scripts": {
		"build": "nuxt build",
		"dev": "nuxt dev",
		"generate": "nuxt generate",
		"preview": "nuxt preview",
		"postinstall": "nuxt prepare"
	},
	"dependencies": {
		"@faker-js/faker": "^10.0.0",
		"@prisma/client": "^6.15.0",
		"bcryptjs": "^3.0.2",
		"next-auth": "^4.24.11",
		"nuxt": "^4.1.1",
		"nuxt-better-auth": "^0.3.1",
		"pg": "^8.16.3",
		"vue": "^3.5.20",
		"vue-router": "^4.5.1"
	},
	"devDependencies": {
		"@types/node": "^24.3.1",
		"cross-env": "^10.0.0",
		"nuxt-auth-utils": "^0.5.24",
		"prisma": "^6.15.0",
		"ts-node": "^10.9.2",
		"tsx": "^4.20.5",
		"typescript": "^5.9.2"
	},
	"prisma": {
		"seed": "tsx prisma/seed.ts"
	}
}


## nuxt.config.ts

export default defineNuxtConfig({
	compatibilityDate: "2025-07-15",
	modules: ["nuxt-auth-utils"],
	devtools: { enabled: true },
	app: {
		head: {
			link: [{ rel: "stylesheet", href: "https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" }],
			script: [{ src: "https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js", tagPosition: "bodyClose" }],
		},
	},
});


## tsconfig.json

{
	"extends": "./.nuxt/tsconfig.json"
}


## .env

# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

# Database Postgre
DB_USER=tilnede0x1182
DB_PASSWORD=tilnede0x1182
DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@localhost:5432/plant_shop_nuxtjs"

# Auth Nuxt (équivalents NEXTAUTH_*)
NUXT_SESSION_PASSWORD=a6d4f3b2c1hjkhkhkjhjkhe5d7a9f0b1c2d3e4f5061728394a5b6chkjhkjh7d8e9f0011223344556677


## Makefile

# Lancer en mode développement
run:
	NITRO_PORT=3150 NITRO_PORT=3150 npm run dev

# Builder le projet (production build)
build:
	npm run build

# Lancer en mode production (après build)
prod:
	NITRO_PORT=3150 npm run start


## prisma/schema.prisma

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             Int      @id @default(autoincrement())
  email          String   @unique
  name           String?
  password       String
  admin          Boolean  @default(false)
  orders         Order[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Plant {
  id          Int         @id @default(autoincrement())
  name        String
  price       Int
  description String?
  stock       Int         @default(0)
  orderItems  OrderItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Order {
  id          Int         @id @default(autoincrement())
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      Int
  totalPrice  Int?
  status      String?
  orderItems  OrderItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model OrderItem {
  id       Int    @id @default(autoincrement())
  orderId  Int
  plantId  Int
  quantity Int
  order    Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  plant    Plant  @relation(fields: [plantId], references: [id], onDelete: Cascade)
}



# TOUS LES FICHIERS PERTINENTS
#
## .env

# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

# Database Postgre
DB_USER=tilnede0x1182
DB_PASSWORD=tilnede0x1182
DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@localhost:5432/plant_shop_nuxtjs"

# Auth Nuxt (équivalents NEXTAUTH_*)
NUXT_SESSION_PASSWORD=a6d4f3b2c1hjkhkhkjhjkhe5d7a9f0b1c2d3e4f5061728394a5b6chkjhkjh7d8e9f0011223344556677


## tsconfig.json

{
	"extends": "./.nuxt/tsconfig.json"
}


## tsconfig.seed.json

{
	"compilerOptions": {
		"target": "ES2020",
		"module": "ESNext",
		"moduleResolution": "bundler",
		"esModuleInterop": true,
		"strict": true,
		"skipLibCheck": true,
		"types": ["node"]
	},
	"include": ["prisma/**/*.ts"]
}


## import-test.ts

// import-test.ts

// Fonction pour tester les imports
async function testImports() {
	// Option 1 - Imports directs
	try {
		const module1 = await import("nuxt-better-auth");
		console.log("✅ Option 1 - nuxt-better-auth : OK", Object.keys(module1));
	} catch (e) {
		console.log("❌ Option 1 - nuxt-better-auth :", e.message);
	}

	// Option 2 - Client via /client
	try {
		const module2 = await import("nuxt-better-auth/client");
		console.log("✅ Option 2 - nuxt-better-auth/client : OK", Object.keys(module2));
	} catch (e) {
		console.log("❌ Option 2 - nuxt-better-auth/client :", e.message);
	}

	// Option 3 - Server via /server
	try {
		const module3 = await import("nuxt-better-auth/server");
		console.log("✅ Option 3 - nuxt-better-auth/server : OK", Object.keys(module3));
	} catch (e) {
		console.log("❌ Option 3 - nuxt-better-auth/server :", e.message);
	}

	// Option 4 - Via runtime
	try {
		const module4 = await import("nuxt-better-auth/runtime");
		console.log("✅ Option 4 - nuxt-better-auth/runtime : OK", Object.keys(module4));
	} catch (e) {
		console.log("❌ Option 4 - nuxt-better-auth/runtime :", e.message);
	}

	// Option 5 - Client via runtime
	try {
		const module5 = await import("nuxt-better-auth/runtime/client");
		console.log("✅ Option 5 - nuxt-better-auth/runtime/client : OK", Object.keys(module5));
	} catch (e) {
		console.log("❌ Option 5 - nuxt-better-auth/runtime/client :", e.message);
	}

	// Option 6 - Server via runtime
	try {
		const module6 = await import("nuxt-better-auth/runtime/server");
		console.log("✅ Option 6 - nuxt-better-auth/runtime/server : OK", Object.keys(module6));
	} catch (e) {
		console.log("❌ Option 6 - nuxt-better-auth/runtime/server :", e.message);
	}

	// Vérifiez également les imports des versions complètes (dist)
	try {
		const module7 = await import("nuxt-better-auth/dist/runtime/composables");
		console.log("✅ Option 7 - nuxt-better-auth/dist/runtime/composables : OK", Object.keys(module7));
	} catch (e) {
		console.log("❌ Option 7 - nuxt-better-auth/dist/runtime/composables :", e.message);
	}

	try {
		const module8 = await import("nuxt-better-auth/dist/runtime/server");
		console.log("✅ Option 8 - nuxt-better-auth/dist/runtime/server : OK", Object.keys(module8));
	} catch (e) {
		console.log("❌ Option 8 - nuxt-better-auth/dist/runtime/server :", e.message);
	}
}

// Exécuter les tests
testImports();


## components/UserMenu.vue

<script setup lang="ts">
const { loggedIn, user, clear } = useUserSession();

async function logout() {
	await $fetch("/api/auth/logout", { method: "POST" });
	await clear();
	await navigateTo('/')
	if (typeof window !== "undefined") window.location.reload();
}
</script>

<template>
	<div v-if="loggedIn && user" class="dropdown">
		<button class="btn btn-outline-light dropdown-toggle" type="button" data-bs-toggle="dropdown">
			{{ user.name || user.email }}
		</button>
		<ul class="dropdown-menu dropdown-menu-end">
			<li>
				<NuxtLink :to="`/users/${user.id}`" class="dropdown-item">Profil</NuxtLink>
			</li>
			<li>
				<NuxtLink to="/orders" class="dropdown-item">Mes commandes</NuxtLink>
			</li>
			<li v-if="user.admin">
				<NuxtLink to="/admin/plants" class="dropdown-item">Admin Plantes</NuxtLink>
			</li>
			<li v-if="user.admin">
				<NuxtLink to="/admin/users" class="dropdown-item">Admin Utilisateurs</NuxtLink>
			</li>
			<li><hr class="dropdown-divider" /></li>
			<li>
				<button class="dropdown-item text-danger" @click="logout">Déconnexion</button>
			</li>
		</ul>
	</div>
</template>


## components/FlashMessages.vue

<script setup lang="ts">
import { ref } from "vue";

const notice = ref("");
const alert = ref("");

// Exemple d’utilisation :
// injectez notice.value = "Succès !" ou alert.value = "Erreur"
</script>

<template>
	<div>
		<div v-if="notice" class="alert alert-success">{{ notice }}</div>
		<div v-if="alert" class="alert alert-danger">{{ alert }}</div>
	</div>
</template>


## components/CartWidget.vue

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'

const count = ref(0)

function loadCartCount() {
	try {
		const cart = JSON.parse(localStorage.getItem('cart') || '{}')
		count.value = Array.isArray(cart)
			? cart.reduce((t, i) => t + (i.quantity || 0), 0)
			: Object.values(cart).reduce((t: number, i: any) => t + (i.quantity || 0), 0)
	} catch {
		count.value = 0
	}
}

// Handler pour l'événement storage pour détecter les changements du panier
function handleStorageChange(event: StorageEvent) {
    if (event.key === 'cart') {
        loadCartCount();
    }
}

onMounted(() => {
    loadCartCount();
    window.addEventListener('storage', handleStorageChange);

    // Écouter un événement personnalisé pour les mises à jour du panier
    window.addEventListener('cart-updated', loadCartCount);
});

onUnmounted(() => {
    window.removeEventListener('storage', handleStorageChange);
    window.removeEventListener('cart-updated', loadCartCount);
});
</script>

<template>
	<NuxtLink to="/cart" class="btn btn-outline-light position-relative">
		🛒
		<span v-if="count > 0" class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger">
			{{ count }}
		</span>
	</NuxtLink>
</template>


## components/Navbar.vue

<script setup lang="ts">
const { loggedIn, user, clear } = useUserSession();

// --- Compteur panier (même logique que le modèle Next) ----------------------
import { ref, onMounted, onUnmounted } from "vue";

const cartCount = ref<number>(0);

function updateCartCount() {
	try {
		const raw = localStorage.getItem("cart") || "{}";
		const cart = JSON.parse(raw);
		const total = Array.isArray(cart) ? cart.reduce((t, i) => t + (i.quantity || 0), 0) : Object.values(cart).reduce((t: number, i: any) => t + (i.quantity || 0), 0);
		cartCount.value = total;
	} catch {
		cartCount.value = 0;
	}
}

onMounted(() => {
	updateCartCount();
	window.addEventListener("storage", updateCartCount);
	window.addEventListener("cart-updated", updateCartCount);
});
onUnmounted(() => {
	window.removeEventListener("storage", updateCartCount);
	window.removeEventListener("cart-updated", updateCartCount);
});
// ---------------------------------------------------------------------------

async function logout() {
	await $fetch("/api/auth/logout", { method: "POST" });
	await clear();
	await navigateTo("/");
	if (typeof window !== "undefined") window.location.reload();
}
</script>

<template>
	<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
		<div class="container">
			<NuxtLink class="navbar-brand" to="/">PlantShop</NuxtLink>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
				<span class="navbar-toggler-icon"></span>
			</button>

			<div class="collapse navbar-collapse" id="navbarNav">
				<ul class="navbar-nav ms-auto">
					<li class="nav-item">
						<NuxtLink class="nav-link" to="/cart" id="cart-link">
							Panier<span v-if="cartCount > 0"> ({{ cartCount }})</span>
						</NuxtLink>
					</li>

					<template v-if="loggedIn">
						<li class="nav-item">
							<NuxtLink class="nav-link" to="/orders">Mes Commandes</NuxtLink>
						</li>
						<li class="nav-item">
							<NuxtLink class="nav-link" :to="`/users/${user?.id}`">Mon Profil</NuxtLink>
						</li>
						<li v-if="user?.admin" class="nav-item dropdown">
							<a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">Admin</a>
							<ul class="dropdown-menu">
								<li><NuxtLink class="dropdown-item" to="/admin/plants">Gestion Plantes</NuxtLink></li>
								<li><NuxtLink class="dropdown-item" to="/admin/users">Gestion Utilisateurs</NuxtLink></li>
							</ul>
						</li>
						<li class="nav-item">
							<button class="btn btn-link nav-link" @click="logout">Déconnexion</button>
						</li>
					</template>

					<template v-else>
						<li class="nav-item">
							<NuxtLink class="nav-link" to="/auth/signin">Connexion</NuxtLink>
						</li>
						<li class="nav-item">
							<NuxtLink class="nav-link" to="/auth/register">Inscription</NuxtLink>
						</li>
					</template>
				</ul>
			</div>
		</div>
	</nav>
</template>


## prisma/schema.prisma

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             Int      @id @default(autoincrement())
  email          String   @unique
  name           String?
  password       String
  admin          Boolean  @default(false)
  orders         Order[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Plant {
  id          Int         @id @default(autoincrement())
  name        String
  price       Int
  description String?
  stock       Int         @default(0)
  orderItems  OrderItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Order {
  id          Int         @id @default(autoincrement())
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      Int
  totalPrice  Int?
  status      String?
  orderItems  OrderItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model OrderItem {
  id       Int    @id @default(autoincrement())
  orderId  Int
  plantId  Int
  quantity Int
  order    Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  plant    Plant  @relation(fields: [plantId], references: [id], onDelete: Cascade)
}


## prisma/seed.ts

// # Importations
import { PrismaClient, Prisma, User, Plant } from '@prisma/client'
import { faker } from '@faker-js/faker'
import bcrypt from 'bcryptjs'
import { writeFileSync } from 'node:fs'
import { join } from 'node:path'

// # Données
const NB_ADMINS	= 3
const NB_USERS	= 20
const NB_PLANTS	= 30
const MAX_ORDERS_PER_USER = 7
const PLANT_NAMES = [
	'Rose','Tulipe','Lavande','Orchidée','Basilic','Menthe','Pivoine','Tournesol',
	'Cactus (Echinopsis)','Bambou','Camomille (Matricaria recutita)','Sauge (Salvia officinalis)',
	'Romarin (Rosmarinus officinalis)','Thym (Thymus vulgaris)','Laurier-rose (Nerium oleander)',
	'Aloe vera','Jasmin (Jasminum officinale)','Hortensia (Hydrangea macrophylla)',
	'Marguerite (Leucanthemum vulgare)','Géranium (Pelargonium graveolens)','Fuchsia (Fuchsia magellanica)',
	'Anémone (Anemone coronaria)','Azalée (Rhododendron simsii)','Chrysanthème (Chrysanthemum morifolium)',
	'Digitale pourpre (Digitalis purpurea)','Glaïeul (Gladiolus hortulanus)','Lys (Lilium candidum)',
	'Violette (Viola odorata)','Muguet (Convallaria majalis)','Iris (Iris germanica)',
	'Lavandin (Lavandula intermedia)','Érable du Japon (Acer palmatum)','Citronnelle (Cymbopogon citratus)',
	'Pin parasol (Pinus pinea)','Cyprès (Cupressus sempervirens)','Olivier (Olea europaea)',
	'Papyrus (Cyperus papyrus)','Figuier (Ficus carica)','Eucalyptus (Eucalyptus globulus)',
	'Acacia (Acacia dealbata)','Bégonia (Begonia semperflorens)','Calathea (Calathea ornata)',
	'Dieffenbachia (Dieffenbachia seguine)','Ficus elastica','Sansevieria (Sansevieria trifasciata)',
	'Philodendron (Philodendron scandens)','Yucca (Yucca elephantipes)','Zamioculcas zamiifolia',
	'Monstera deliciosa','Pothos (Epipremnum aureum)','Agave (Agave americana)',
	'Cactus raquette (Opuntia ficus-indica)','Palmier-dattier (Phoenix dactylifera)',
	'Amaryllis (Hippeastrum hybridum)','Bleuet (Centaurea cyanus)',
	'Cœur-de-Marie (Lamprocapnos spectabilis)','Croton (Codiaeum variegatum)',
	'Dracaena (Dracaena marginata)','Hosta (Hosta plantaginea)','Lierre (Hedera helix)',
	'Mimosa (Acacia dealbata)'
]

// # Classe SeedService
class SeedService {
	private prisma = new PrismaClient()

	// ## Reset
	private reset = async (): Promise<void> => {
		await this.prisma.orderItem.deleteMany()
		await this.prisma.order.deleteMany()
		await this.prisma.plant.deleteMany()
		await this.prisma.user.deleteMany()
	}

	// ## Admins
	private createAdmins = async () => {
		const admins: { email: string; password: string }[] = []
		for (let idx = 0; idx < NB_ADMINS; idx++) admins.push(await this.addAdmin(idx))
		return admins
	}

	private addAdmin = async (index: number) => {
		const email = `admin${index + 1}@planteshop.com`
		const password = 'password'
		await this.prisma.user.create({
			data: { email, password: await bcrypt.hash(password, 10), admin: true, name: faker.person.fullName() }
		})
		return { email, password }
	}

	// ## Users
	private createUsers = async () => {
		const users: { email: string; password: string }[] = []
		for (let idx = 0; idx < NB_USERS; idx++) users.push(await this.addUser())
		return users
	}

	private addUser = async () => {
		const password = faker.internet.password({ length: 12 })
		const email = faker.internet.email().toLowerCase()
		await this.prisma.user.create({
			data: { email, password: await bcrypt.hash(password, 10), admin: false, name: faker.person.fullName() }
		})
		return { email, password }
	}

	// ## Plants
	private createPlants = async () => {
		const max = PLANT_NAMES.length
		const plants: Plant[] = []
		for (let idx = 0; idx < NB_PLANTS; idx++) plants.push(await this.addPlant(idx, max))
		return plants
	}

	private addPlant = async (idx: number, max: number) => {
		const base = PLANT_NAMES[idx % max]
		const name = NB_PLANTS > max ? `${base} ${Math.floor(idx / max) + 1}` : base
		return this.prisma.plant.create({
			data: {
				name,
				price: faker.number.int({ min: 5, max: 50 }),
				description: faker.lorem.sentence({ min: 10, max: 14 }),
				stock: faker.number.int({ min: 5, max: 30 })
			}
		})
	}

	// ## Orders
	private createOrders = async (plants: Plant[]) => {
		for (const user of await this.prisma.user.findMany()) {
			const numberOfOrders = faker.number.int({ min: 0, max: MAX_ORDERS_PER_USER })
			for (let idx = 0; idx < numberOfOrders; idx++) {
				await this.createOrderForUser(user, plants)
			}
		}
	}

	private createOrderForUser = async (user: User, plants: Plant[]) => {
		let total = 0
		const order = await this.prisma.order.create({
			data: { userId: user.id, totalPrice: 0, status: faker.helpers.arrayElement(['confirmed','pending','shipped','delivered']) }
		})
		for (let iter = 0; iter < 2; iter++) total += await this.addItem(order.id, plants)
		await this.prisma.order.update({ where: { id: order.id }, data: { totalPrice: total } })
	}

	private addItem = async (orderId: number, plants: Plant[]) => {
		const plant = plants[Math.floor(Math.random() * plants.length)]
		if (!plant.stock) return 0
		const qty = Math.min(faker.number.int({ min: 1, max: 5 }), plant.stock)
		if (!qty) return 0
		await this.prisma.orderItem.create({ data: { orderId, plantId: plant.id, quantity: qty } })
		await this.prisma.plant.update({ where: { id: plant.id }, data: { stock: plant.stock - qty } })
		plant.stock -= qty
		return plant.price * qty
	}

	// ## users.txt
	private writeUsersFile = (admins: {email:string;password:string}[], users: {email:string;password:string}[]) => {
		const path = join(process.cwd(), 'users.txt')
		let txt = 'Administrateurs :\n\n'
		admins.forEach(admin => (txt += `${admin.email} ${admin.password}\n`))
		txt += '\nUtilisateurs :\n\n'
		users.forEach(u => (txt += `${u.email} ${u.password}\n`))
		writeFileSync(path, txt, 'utf8')
	}

	// # Main
	public run = async (): Promise<void> => {
		await this.reset()
		const admins = await this.createAdmins()
		const users = await this.createUsers()
		const plants = await this.createPlants()
		this.writeUsersFile(admins, users)
		await this.createOrders(plants)
		console.log('✅ Seed terminée. Données créées & users.txt généré.')
		await this.prisma.$disconnect()
	}
}

// # Lancement
new SeedService().run().catch(err => {
	console.error(err)
	process.exit(1)
})


## nuxt.config.ts

export default defineNuxtConfig({
	compatibilityDate: "2025-07-15",
	modules: ["nuxt-auth-utils"],
	devtools: { enabled: true },
	app: {
		head: {
			link: [{ rel: "stylesheet", href: "https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" }],
			script: [{ src: "https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js", tagPosition: "bodyClose" }],
		},
	},
});


## layouts/default.vue

<script setup lang="ts">
</script>

<template>
	<div>
		<!-- Navigation -->
		<Navbar />

		<!-- Messages globaux -->
		<div class="container mt-3">
			<FlashMessages />
		</div>

		<!-- Contenu -->
		<slot />
	</div>
</template>


## pages/admin/plants/[id].vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'


/**
 * Détail plante côté admin
 * Affiche et permet suppression
 * @plant ressource chargée
 */
const route = useRoute()
const router = useRouter()
const plant = ref<any>(null)

onMounted(async () => {
	plant.value = await $fetch(`/api/plants/${route.params.id}`)
})

async function deletePlant() {
	if (!confirm('Supprimer cette plante ?')) return
	await $fetch(`/api/admin/plants/${route.params.id}`, { method: 'DELETE' })
	router.push('/admin/plants')
}
</script>

<template>
	<div v-if="plant" class="container mt-4">
		<h1>{{ plant.name }}</h1>
		<p><strong>Prix :</strong> {{ plant.price }} €</p>
		<p><strong>Stock :</strong> {{ plant.stock }}</p>
		<div class="mt-3">
			<NuxtLink :to="`/admin/plants/${plant.id}/edit`" class="btn btn-warning me-2">Modifier</NuxtLink>
			<button class="btn btn-danger" @click="deletePlant">Supprimer</button>
		</div>
	</div>
</template>


## pages/admin/plants/index.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'

type Plant = { id: number; name: string; price: number; stock: number }
const plants = ref<Plant[]>([])

onMounted(async () => {
	plants.value = await $fetch('/api/admin/plants')
})

async function deletePlant(id: number) {
	if (!confirm('Supprimer cette plante ?')) return
	await $fetch(`/api/admin/plants/${id}`, { method: 'DELETE' })
	plants.value = plants.value.filter(p => p.id !== id)
}
</script>

<template>
	<div class="container mt-4">
		<h1>Gestion des Plantes (Admin)</h1>
		<NuxtLink to="/admin/plants/new" class="btn btn-success mb-3">Nouvelle Plante</NuxtLink>
		<table class="table table-striped">
			<thead class="table-light">
				<tr><th>Nom</th><th>Prix</th><th>Stock</th><th>Actions</th></tr>
			</thead>
			<tbody>
				<tr v-for="plant in plants" :key="plant.id">
					<td><NuxtLink :to="`/plants/${plant.id}`">{{ plant.name }}</NuxtLink></td>
					<td>{{ plant.price }} €</td>
					<td>{{ plant.stock }}</td>
					<td>
						<NuxtLink :to="`/admin/plants/${plant.id}/edit`" class="btn btn-warning btn-sm me-2">✏ Modifier</NuxtLink>
						<button class="btn btn-danger btn-sm" @click="deletePlant(plant.id)">🗑 Supprimer</button>
					</td>
				</tr>
			</tbody>
		</table>
	</div>
</template>


## pages/admin/plants/new.vue

<script setup lang="ts">
import { ref } from 'vue'
import { useRoute, useRouter } from '#app'


/**
 * Formulaire création plante (admin)
 * Valide la SFC et crée une plante
 * @form données du formulaire
 */
const router = useRouter()
const form = ref({ name: '', price: 0, description: '', stock: 0 })

async function handleSubmit() {
	await $fetch('/api/plants', { method: 'POST', body: form.value })
	router.push('/admin/plants')
}
</script>

<template>
	<div class="container mt-4">
		<h1>Nouvelle Plante 🌱</h1>
		<form @submit.prevent="handleSubmit">
			<div class="mb-3"><label>Nom</label><input v-model="form.name" class="form-control" required /></div>
			<div class="mb-3"><label>Prix (€)</label><input v-model="form.price" type="number" class="form-control" required /></div>
			<div class="mb-3"><label>Description</label><textarea v-model="form.description" class="form-control" rows="4"></textarea></div>
			<div class="mb-3"><label>Stock</label><input v-model="form.stock" type="number" class="form-control" required /></div>
			<button class="btn btn-success">Créer</button>
		</form>
	</div>
</template>


## pages/admin/plants/[id]/edit.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'


const route = useRoute()
const router = useRouter()
const form = ref({ name: '', price: 0, description: '', stock: 0 })

onMounted(async () => {
	const data = await $fetch(`/api/plants/${route.params.id}`)
	form.value = data
})

async function handleSubmit() {
	await $fetch(`/api/plants/${route.params.id}`, { method: 'PUT', body: form.value })
	router.push('/admin/plants')
}
</script>

<template>
	<div class="container mt-4">
		<h1>Modifier la Plante</h1>
		<form @submit.prevent="handleSubmit">
			<div class="mb-3"><label>Nom</label><input v-model="form.name" class="form-control" required /></div>
			<div class="mb-3"><label>Prix (€)</label><input v-model="form.price" type="number" class="form-control" required /></div>
			<div class="mb-3"><label>Description</label><textarea v-model="form.description" class="form-control"></textarea></div>
			<div class="mb-3"><label>Stock</label><input v-model="form.stock" type="number" class="form-control" required /></div>
			<button class="btn btn-primary">Enregistrer</button>
		</form>
	</div>
</template>


## pages/admin/users/[id].vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute } from 'vue-router'

const route = useRoute()
const user = ref<any>(null)

onMounted(async () => {
	user.value = await $fetch(`/api/users/${route.params.id}`)
})
</script>

<template>
	<div v-if="user" class="container mt-4">
		<h1>Détails Utilisateur</h1>
		<p><strong>Email :</strong> {{ user.email }}</p>
		<p><strong>Nom :</strong> {{ user.name || '-' }}</p>
		<p><strong>Administrateur :</strong> {{ user.admin ? 'Oui' : 'Non' }}</p>
		<NuxtLink :to="`/admin/users/${user.id}/edit`" class="btn btn-warning mt-3">Modifier</NuxtLink>
	</div>
</template>


## pages/admin/users/index.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'

type User = { id: number; email: string; name?: string; admin: boolean }
const users = ref<User[]>([])

onMounted(async () => {
	users.value = await $fetch('/api/users')
})
</script>

<template>
	<div class="container mt-4">
		<h1>Gestion des Utilisateurs</h1>
		<table class="table table-striped mt-3">
			<thead class="table-light">
				<tr><th>Nom</th><th>Email</th><th>Admin</th><th>Actions</th></tr>
			</thead>
			<tbody>
				<tr v-for="user in users" :key="user.id">
					<td><NuxtLink :to="`/admin/users/${user.id}`">{{ user.name || '-' }}</NuxtLink></td>
					<td>{{ user.email }}</td>
					<td>
						<span :class="['badge', user.admin ? 'bg-success' : 'bg-secondary']">
							{{ user.admin ? 'Oui' : 'Non' }}
						</span>
					</td>
					<td>
						<NuxtLink :to="`/admin/users/${user.id}/edit`" class="btn btn-warning btn-sm">✏ Modifier</NuxtLink>
					</td>
				</tr>
			</tbody>
		</table>
	</div>
</template>


## pages/admin/users/[id]/edit.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'


const route = useRoute()
const router = useRouter()
const form = ref({ email: '', name: '', admin: false })

onMounted(async () => {
	const data = await $fetch(`/api/users/${route.params.id}`)
	form.value = { email: data.email, name: data.name, admin: data.admin }
})

async function handleSubmit() {
	await $fetch(`/api/users/${route.params.id}`, { method: 'PUT', body: form.value })
	router.push(`/admin/users/${route.params.id}`)
}
</script>

<template>
	<div class="container mt-4">
		<h1>Modifier Utilisateur</h1>
		<form @submit.prevent="handleSubmit">
			<div class="mb-3">
				<label>Email</label>
				<input v-model="form.email" type="email" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Nom</label>
				<input v-model="form.name" type="text" class="form-control" />
			</div>
			<div class="mb-3 form-check">
				<input v-model="form.admin" type="checkbox" class="form-check-input" id="adminCheck" />
				<label for="adminCheck" class="form-check-label">Administrateur</label>
			</div>
			<button class="btn btn-primary">Enregistrer</button>
		</form>
	</div>
</template>


## pages/plants/[id].vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'

const route = useRoute()
const router = useRouter()
const plant = ref<any>(null)

const { user, loggedIn } = useUserSession()
const isAdmin = computed(() => !!(loggedIn.value && user.value?.admin))

onMounted(async () => {
  plant.value = await $fetch(`/api/plants/${route.params.id}`)
})

async function deletePlant() {
  if (!plant.value) return
  if (!confirm('Supprimer cette plante ?')) return
  await $fetch(`/api/admin/plants/${route.params.id}`, { method: 'DELETE' })
  router.push('/plants')
}

function addToCart() {
  if (!plant.value) return

  let cart: Record<number, any>
  try {
    cart = JSON.parse(localStorage.getItem('cart') || '{}')
  } catch {
    cart = {}
  }

  const id = plant.value.id
  cart[id] = cart[id]
    ? { ...cart[id], quantity: cart[id].quantity + 1 }
    : { id: plant.value.id, name: plant.value.name, price: plant.value.price, quantity: 1 }

  localStorage.setItem('cart', JSON.stringify(cart))
  window.dispatchEvent(new Event('cart-updated'))
}
</script>

<template>
  <div v-if="plant" class="container mt-4">
    <h1>{{ plant.name }}</h1>
    <p><strong>Prix :</strong> {{ plant.price }} €</p>
    <p><strong>Description :</strong> {{ plant.description }}</p>
    <p v-if="isAdmin"><strong>Stock :</strong> {{ plant.stock }}</p>

    <div class="mt-3">
      <button class="btn btn-success me-2" @click="addToCart">Ajouter au panier</button>
      <NuxtLink v-if="isAdmin" :to="`/plants/${plant.id}/edit`" class="btn btn-warning me-2">Modifier</NuxtLink>
      <button v-if="isAdmin" class="btn btn-danger" @click="deletePlant">Supprimer</button>
    </div>
  </div>
</template>


## pages/plants/index.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'

type Plant = { id: number; name: string; price: number; stock: number }

const plants = ref<Plant[]>([])
const { user, loggedIn } = useUserSession()
const isAdmin = computed(() => !!(loggedIn.value && user.value?.admin))

onMounted(async () => {
  plants.value = await $fetch('/api/plants')
})
</script>

<template>
  <div class="container mt-4">
    <h1 class="mb-4">Liste des Plantes</h1>
    <NuxtLink v-if="isAdmin" to="/admin/plants/new" class="btn btn-success mb-3">
      Nouvelle Plante
    </NuxtLink>
    <div class="row">
      <div v-for="plant in plants" :key="plant.id" class="col-md-4">
        <div class="card mb-3 shadow-sm">
          <div class="card-body">
            <h5 class="card-title">
              <NuxtLink :to="`/plants/${plant.id}`" class="text-decoration-none text-dark">
                {{ plant.name }}
              </NuxtLink>
            </h5>
            <p><strong>Prix :</strong> {{ plant.price }} €</p>
            <p v-if="isAdmin"><strong>Stock :</strong> {{ plant.stock }}</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>


## pages/plants/new.vue

<script setup lang="ts">
import { ref } from 'vue'
import { useRoute, useRouter } from '#app'


const router = useRouter()
const form = ref({ name: '', price: 0, description: '', stock: 0 })

async function handleSubmit() {
	await $fetch('/api/plants', { method: 'POST', body: form.value })
	router.push('/plants')
}
</script>

<template>
	<div class="container mt-4">
		<h1>Nouvelle Plante 🌱</h1>
		<form @submit.prevent="handleSubmit">
			<div class="mb-3">
				<label>Nom</label>
				<input v-model="form.name" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Prix (€)</label>
				<input v-model="form.price" type="number" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Description</label>
				<textarea v-model="form.description" class="form-control" rows="4"></textarea>
			</div>
			<div class="mb-3">
				<label>Stock</label>
				<input v-model="form.stock" type="number" class="form-control" required />
			</div>
			<button class="btn btn-success">Créer</button>
		</form>
	</div>
</template>


## pages/plants/[id]/edit.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'


const route = useRoute()
const router = useRouter()
const form = ref({ name: '', price: 0, description: '', stock: 0 })

onMounted(async () => {
	const data = await $fetch(`/api/plants/${route.params.id}`)
	form.value = data
})

async function handleSubmit() {
	await $fetch(`/api/plants/${route.params.id}`, {
		method: 'PUT',
		body: form.value
	})
	router.push(`/plants/${route.params.id}`)
}
</script>

<template>
	<div class="container mt-4">
		<h1>Éditer la Plante</h1>
		<form @submit.prevent="handleSubmit">
			<div class="mb-3">
				<label>Nom</label>
				<input v-model="form.name" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Prix (€)</label>
				<input v-model="form.price" type="number" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Description</label>
				<textarea v-model="form.description" class="form-control" rows="4"></textarea>
			</div>
			<div class="mb-3">
				<label>Stock</label>
				<input v-model="form.stock" type="number" class="form-control" required />
			</div>
			<button class="btn btn-primary">Enregistrer</button>
		</form>
	</div>
</template>


## pages/orders/index.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'

type OrderItem = { id: number; quantity: number; plant: { id: number; name: string; price: number } }
type Order = { id: number; createdAt: string; totalPrice: number; status: string; orderItems: OrderItem[] }

const orders = ref<Order[]>([])

onMounted(async () => {
	orders.value = await $fetch('/api/orders').catch(() => [])
})
</script>

<template>
	<div class="container mt-4">
		<h1>📜 Mes Commandes</h1>
		<div v-if="!orders.length" class="alert alert-info mt-3">
			Aucune commande pour le moment.
		</div>
		<div v-for="(order, index) in orders" :key="order.id" class="card mb-3 shadow-sm">
			<div class="card-body">
				<h5 class="card-title">Commande n°{{ orders.length - index }}</h5>
				<p class="text-muted">Passée le {{ new Date(order.createdAt).toLocaleString() }}</p>
				<ul>
					<li v-for="item in order.orderItems" :key="item.id">
						<NuxtLink :to="`/plants/${item.plant.id}`">{{ item.plant.name }}</NuxtLink>
						– {{ item.quantity }} × {{ item.plant.price }} €
					</li>
				</ul>
				<p><strong>Total :</strong> {{ order.totalPrice }} €</p>
				<p><strong>Statut :</strong> {{ order.status }}</p>
			</div>
		</div>
	</div>
</template>


## pages/orders/new.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRouter } from '#app'

type CartItem = { id: number; name: string; price: number; quantity: number }
const cartItems = ref<CartItem[]>([])
const error = ref('')
const router = useRouter()

const { loggedIn } = useUserSession()

onMounted(() => {
  const stored = localStorage.getItem('cart')
  if (!stored) return
  let parsed = JSON.parse(stored)
  if (!Array.isArray(parsed) && typeof parsed === 'object') parsed = Object.values(parsed)
  cartItems.value = parsed
})

async function confirmOrder() {
  if (!loggedIn.value) {
    error.value = 'Utilisateur non connecté.'
    return
  }
  const res = await $fetch('/api/orders', {
    method: 'POST',
    body: { items: cartItems.value.map(i => ({ plant_id: i.id, quantity: i.quantity })) }
  }).catch(err => ({ error: err?.data?.message || err?.message }))
  if ((res as any)?.error) {
    error.value = (res as any).error || 'Erreur commande'
    return
  }
  localStorage.removeItem('cart')
  window.dispatchEvent(new Event('cart-updated'))
  router.push('/orders')
}
</script>

<template>
  <div class="container mt-4">
    <h1>Valider ma commande</h1>
    <div v-if="error" class="alert alert-danger">{{ error }}</div>
    <div v-if="!cartItems.length" class="alert alert-info">Votre panier est vide.</div>
    <div v-else>
      <table class="table shadow">
        <thead class="table-light">
          <tr><th>Plante</th><th>Quantité</th><th>Total</th></tr>
        </thead>
        <tbody>
          <tr v-for="item in cartItems" :key="item.id">
            <td><NuxtLink :to="`/plants/${item.id}`">{{ item.name }}</NuxtLink></td>
            <td>{{ item.quantity }}</td>
            <td>{{ item.price * item.quantity }} €</td>
          </tr>
        </tbody>
      </table>
      <p class="fw-bold text-end">Total : {{ cartItems.reduce((t,i)=>t + i.price*i.quantity, 0) }} €</p>
      <button class="btn btn-success w-100" @click="confirmOrder">Confirmer la commande</button>
    </div>
  </div>
</template>


## pages/bootstrap-check.vue

<template>
  <div class="container py-4">
    <h1 class="mb-3">Vérif Bootstrap</h1>
    <p>
      <button class="btn btn-primary" type="button" data-bs-toggle="collapse" data-bs-target="#demo">
        Bouton Bootstrap
      </button>
    </p>
    <div id="demo" class="collapse">
      <div class="alert alert-success mb-0">OK : CSS + JS actives.</div>
    </div>
  </div>
</template>


## pages/index.vue

<script setup lang="ts">
/**
 * Accueil : redirige vers le catalogue
 * Simplifie la navigation depuis "/"
 */
await navigateTo('/plants')
</script>

<template></template>


## pages/cart.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'

type CartItem = { id: number; name: string; price: number; quantity: number; stock: number }
const cart = ref<Record<number, CartItem>>({})

function loadCart() {
	try {
		return JSON.parse(localStorage.getItem('cart') || '{}')
	} catch {
		return {}
	}
}

function saveCart(c: Record<number, CartItem>) {
	localStorage.setItem('cart', JSON.stringify(c))
	cart.value = c
}

function removeItem(id: number) {
	const c = { ...cart.value }
	delete c[id]
	saveCart(c)
}

onMounted(() => {
	cart.value = loadCart()
})
</script>

<template>
	<div class="container mt-4">
		<h1>🛒 Mon Panier</h1>
		<div v-if="!Object.keys(cart).length" class="alert alert-info mt-3">
			Votre panier est vide.
		</div>
		<table v-else class="table mt-3">
			<thead class="table-light">
				<tr>
					<th>Plante</th>
					<th>Quantité</th>
					<th>Total</th>
					<th></th>
				</tr>
			</thead>
			<tbody>
				<tr v-for="item in cart" :key="item.id">
					<td>{{ item.name }}</td>
					<td>{{ item.quantity }}</td>
					<td>{{ item.price * item.quantity }} €</td>
					<td>
						<button class="btn btn-danger btn-sm" @click="removeItem(item.id)">Retirer</button>
					</td>
				</tr>
			</tbody>
		</table>
		<div v-if="Object.keys(cart).length" class="mt-3 text-end">
			<NuxtLink to="/orders/new" class="btn btn-primary">Passer la commande</NuxtLink>
		</div>
	</div>
</template>


## pages/auth/unauthorized.vue

<template>
	<div class="container mt-4">
		<div class="alert alert-danger">
			🚫 Accès refusé. Vous n’avez pas les droits suffisants.
		</div>
		<NuxtLink to="/" class="btn btn-primary mt-3">Retour à l’accueil</NuxtLink>
	</div>
</template>


## pages/auth/signin.vue

<script setup lang="ts">
import { ref } from "vue";

const email = ref("");
const password = ref("");
const error = ref("");

async function handleLogin() {
	try {
		const res = await $fetch("/api/auth/login", {
			method: "POST",
			body: { email: email.value, password: password.value },
		});
		if (res?.ok) {
			await navigateTo('/')
			if (typeof window !== "undefined") window.location.reload();
		} else {
			error.value = "Email ou mot de passe invalide";
		}
	} catch {
		error.value = "Email ou mot de passe invalide";
	}
}
</script>

<template>
	<div class="container mt-4">
		<h1>Se connecter</h1>
		<form @submit.prevent="handleLogin" class="mt-3" style="max-width: 400px">
			<div class="mb-3">
				<label>Email</label>
				<input v-model="email" type="email" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Mot de passe</label>
				<input v-model="password" type="password" class="form-control" required />
			</div>
			<div v-if="error" class="alert alert-danger">{{ error }}</div>
			<button class="btn btn-primary w-100" type="submit">Connexion</button>
		</form>
	</div>
</template>


## pages/auth/register.vue

<script setup lang="ts">
import { ref } from 'vue'

const email = ref('')
const name = ref('')
const password = ref('')
const passwordConfirmation = ref('')
const error = ref('')

async function handleRegister() {
	if (password.value !== passwordConfirmation.value) {
		error.value = 'Les mots de passe ne correspondent pas'
		return
	}
	const res = await $fetch('/api/users', {
		method: 'POST',
		body: { email: email.value, name: name.value, password: password.value }
	})
	if ('error' in res) {
		error.value = (res as any).error
	} else {
		await navigateTo('/auth/signin')
	}
}
</script>

<template>
	<div class="container mt-4">
		<h1>Inscription</h1>
		<form @submit.prevent="handleRegister" class="mt-3" style="max-width:500px">
			<div class="mb-3">
				<label>Email</label>
				<input v-model="email" type="email" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Nom</label>
				<input v-model="name" type="text" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Mot de passe</label>
				<input v-model="password" type="password" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Confirmation mot de passe</label>
				<input v-model="passwordConfirmation" type="password" class="form-control" required />
			</div>
			<div v-if="error" class="alert alert-danger">{{ error }}</div>
			<button class="btn btn-success w-100" type="submit">Créer un compte</button>
		</form>
	</div>
</template>


## pages/users/[id].vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute } from 'vue-router'

const route = useRoute()
const user = ref<any>(null)

onMounted(async () => {
	user.value = await $fetch(`/api/users/${route.params.id}`)
})
</script>

<template>
	<div class="container mt-4" v-if="user">
		<h1>Mon Profil</h1>
		<p><strong>Email :</strong> {{ user.email }}</p>
		<p v-if="user.name"><strong>Nom :</strong> {{ user.name }}</p>
		<NuxtLink :to="`/users/${user.id}/edit`" class="btn btn-primary">
			Modifier mon profil
		</NuxtLink>
	</div>
</template>


## pages/users/[id]/edit.vue

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from '#app'


const route = useRoute()
const router = useRouter()
const form = ref({ email: '', name: '' })
const errors = ref<string[]>([])
const loading = ref(true)

onMounted(async () => {
	const data = await $fetch(`/api/users/${route.params.id}`)
	form.value = { email: data.email || '', name: data.name || '' }
	loading.value = false
})

async function handleSubmit() {
	const res = await $fetch(`/api/users/${route.params.id}`, {
		method: 'PUT',
		body: form.value
	}).catch(async (err) => {
		errors.value = [err.message]
	})
	if (!errors.value.length) router.push(`/users/${route.params.id}`)
}
</script>

<template>
	<div class="container mt-4">
		<h1>Modifier mon profil</h1>
		<p v-if="loading">Chargement...</p>
		<form v-else @submit.prevent="handleSubmit">
			<div class="mb-3">
				<label>Email</label>
				<input v-model="form.email" type="email" class="form-control" required />
			</div>
			<div class="mb-3">
				<label>Nom</label>
				<input v-model="form.name" type="text" class="form-control" />
			</div>
			<div v-if="errors.length" class="alert alert-danger">
				<ul><li v-for="(err,idx) in errors" :key="idx">{{ err }}</li></ul>
			</div>
			<button class="btn btn-primary">Enregistrer</button>
		</form>
	</div>
</template>


## composables/useCart.ts

// composables/useCart.ts
/**
 * Ajout d'une plante au panier localStorage + évènement cart-updated.
 * @param plant objet plante (id, name, price, ...)
 */
export function addToCart(plant: { id: number; name: string; price: number }) {
	let cart: Record<number, any>;
	try {
		cart = JSON.parse(localStorage.getItem("cart") || "{}");
	} catch {
		cart = {};
	}
	const id = plant.id;
	cart[id] = cart[id] ? { ...cart[id], quantity: cart[id].quantity + 1 } : { id: plant.id, name: plant.name, price: plant.price, quantity: 1 };
	localStorage.setItem("cart", JSON.stringify(cart));
	window.dispatchEvent(new Event("cart-updated"));
}


## README.md

# Nuxt Minimal Starter

Look at the [Nuxt documentation](https://nuxt.com/docs/getting-started/introduction) to learn more.

## Setup

Make sure to install dependencies:

```bash
# npm
npm install

# pnpm
pnpm install

# yarn
yarn install

# bun
bun install
```

## Development Server

Start the development server on `http://localhost:3000`:

```bash
# npm
npm run dev

# pnpm
pnpm dev

# yarn
yarn dev

# bun
bun run dev
```

## Production

Build the application for production:

```bash
# npm
npm run build

# pnpm
pnpm build

# yarn
yarn build

# bun
bun run build
```

Locally preview production build:

```bash
# npm
npm run preview

# pnpm
pnpm preview

# yarn
yarn preview

# bun
bun run preview
```

Check out the [deployment documentation](https://nuxt.com/docs/getting-started/deployment) for more information.


## app.vue

<template>
	<NuxtLayout>
		<NuxtPage />
	</NuxtLayout>
</template>


## server/api/admin/plants/[id].ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, sendError, createError } from "h3";

// # Données
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	const id = Number(event.context.params?.id);
	if (isNaN(id)) return sendError(event, createError({ statusCode: 400, statusMessage: "Invalid ID" }));

	if (event.node.req.method === "DELETE") {
		await prisma.plant.delete({ where: { id } });
		return { message: "Plant deleted" };
	}
});


## server/api/admin/plants/index.ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler } from "h3";

// # Données
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async () => {
	// Liste complète des plantes (admin)
	return await prisma.plant.findMany({
		orderBy: { name: "asc" },
	});
});


## server/api/admin/users/[id].ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, sendError, createError } from "h3";

// # Données
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	const id = Number(event.context.params?.id);
	if (isNaN(id)) return sendError(event, createError({ statusCode: 400, statusMessage: "Invalid ID" }));

	if (event.node.req.method === "DELETE") {
		await prisma.user.delete({ where: { id } });
		return { message: "User deleted" };
	}
});


## server/api/plants/[id].ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody, sendError, createError } from "h3";

// # Données
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	const id = Number(event.context.params?.id);
	if (isNaN(id)) return sendError(event, createError({ statusCode: 400, statusMessage: "Invalid ID" }));

	if (event.node.req.method === "GET") {
		const plant = await prisma.plant.findUnique({ where: { id } });
		if (!plant) return sendError(event, createError({ statusCode: 404, statusMessage: "Plant not found" }));
		return plant;
	}

	if (event.node.req.method === "PUT") {
		const data = await readBody(event);
		return await prisma.plant.update({ where: { id }, data });
	}

	if (event.node.req.method === "DELETE") {
		await prisma.plant.delete({ where: { id } });
		return { message: "Plant deleted" };
	}
});


## server/api/plants/index.ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody } from "h3";

// # Données
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	if (event.node.req.method === "GET") {
		// Liste des plantes en stock
		return await prisma.plant.findMany({
			where: { stock: { gte: 1 } },
			orderBy: { name: "asc" },
		});
	}

	if (event.node.req.method === "POST") {
		// Création d’une plante
		const data = await readBody(event);
		return await prisma.plant.create({ data });
	}
});


## server/api/orders/[id].ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody, sendError, createError } from "h3";

// # Données
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	const id = Number(event.context.params?.id);
	if (isNaN(id)) return sendError(event, createError({ statusCode: 400, statusMessage: "Invalid ID" }));

	if (event.node.req.method === "GET") {
		const order = await prisma.order.findUnique({
			where: { id },
			include: { orderItems: true },
		});
		if (!order) return sendError(event, createError({ statusCode: 404, statusMessage: "Order not found" }));
		return order;
	}

	if (event.node.req.method === "PUT") {
		const data = await readBody(event);
		return await prisma.order.update({ where: { id }, data });
	}

	if (event.node.req.method === "DELETE") {
		await prisma.order.delete({ where: { id } });
		return { message: "Order deleted" };
	}
});


## server/api/orders/index.ts

import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody, sendError, createError } from "h3";
// import { requireUserSession } from "nuxt-auth-utils";

const prisma = new PrismaClient();

export default defineEventHandler(async (event) => {
	if (event.node.req.method === "GET") {
		const { user } = await requireUserSession(event);
		const userId = Number(user.id);

		return prisma.order.findMany({
			where: { userId },
			include: { orderItems: { include: { plant: true } } },
		});
	}

	if (event.node.req.method === "POST") {
		const { user } = await requireUserSession(event);
		const userId = Number(user.id);

		const { items } = await readBody<{ items: { plant_id: number; quantity: number }[] }>(event);
		if (!Array.isArray(items) || !items.length) {
			return sendError(event, createError({ statusCode: 400, statusMessage: "Données invalides" }));
		}

		let total = 0;
		const order = await prisma.order.create({ data: { userId, status: "confirmed", totalPrice: 0 } });
		for (const item of items) {
			const plant = await prisma.plant.findUnique({ where: { id: item.plant_id } });
			if (!plant || plant.stock < item.quantity) {
				return sendError(event, createError({ statusCode: 400, statusMessage: `Stock insuffisant pour ${item.plant_id}` }));
			}
			total += plant.price * item.quantity;
			await prisma.plant.update({ where: { id: plant.id }, data: { stock: plant.stock - item.quantity } });
			await prisma.orderItem.create({ data: { orderId: order.id, plantId: plant.id, quantity: item.quantity } });
		}
		return prisma.order.update({ where: { id: order.id }, data: { totalPrice: total } });
	}
});


## server/api/auth/login.post.ts

import { defineEventHandler, readBody, createError } from "h3";
// import { setUserSession } from "nuxt-auth-utils";
import { PrismaClient } from "@prisma/client";
import bcrypt from "bcryptjs";

const prisma = new PrismaClient();

export default defineEventHandler(async (event) => {
	const { email, password } = await readBody<{ email: string; password: string }>(event);
	if (!email || !password) throw createError({ statusCode: 400, statusMessage: "Données invalides" });

	const user = await prisma.user.findUnique({ where: { email } });
	if (!user || !(await bcrypt.compare(password, user.password))) {
		throw createError({ statusCode: 401, statusMessage: "Identifiants invalides" });
	}

	await setUserSession(event, {
		user: { id: String(user.id), email: user.email, name: user.name ?? null, admin: user.admin },
		loggedInAt: new Date(),
	});
	return { ok: true };
});


## server/api/auth/logout.post.ts

import { defineEventHandler } from "h3";
// import { clearUserSession } from "nuxt-auth-utils";

export default defineEventHandler(async (event) => {
	await clearUserSession(event);
	return { ok: true };
});


## server/api/auth/session.get.ts

import { defineEventHandler } from "h3";
// import { getUserSession } from "nuxt-auth-utils";

export default defineEventHandler(async (event) => {
	return await getUserSession(event); // { user, loggedInAt, ... } ou null
});


## server/api/users/[id].ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody, sendError, createError } from "h3";

// # Données
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	const id = Number(event.context.params?.id);
	if (isNaN(id)) return sendError(event, createError({ statusCode: 400, statusMessage: "Invalid ID" }));

	if (event.node.req.method === "GET") {
		const user = await prisma.user.findUnique({ where: { id } });
		if (!user) return sendError(event, createError({ statusCode: 404, statusMessage: "User not found" }));
		return user;
	}

	if (event.node.req.method === "PUT") {
		const data = await readBody(event);
		return await prisma.user.update({ where: { id }, data });
	}

	if (event.node.req.method === "DELETE") {
		await prisma.user.delete({ where: { id } });
		return { message: "User deleted" };
	}
});


## server/api/users/index.ts

// # Importations
import { PrismaClient } from "@prisma/client";
import { defineEventHandler, readBody, sendError, createError } from "h3";
import bcrypt from "bcryptjs";

// # Données
const prisma = new PrismaClient();

// # Handler principal
export default defineEventHandler(async (event) => {
	if (event.node.req.method === "GET") {
		return await prisma.user.findMany({
			orderBy: [{ admin: "desc" }, { name: "asc" }],
		});
	}

	if (event.node.req.method === "POST") {
		const data = await readBody(event);
		try {
			const hashedPassword = await bcrypt.hash(data.password, 10);
			return await prisma.user.create({
				data: {
					email: data.email,
					name: data.name,
					password: hashedPassword,
				},
			});
		} catch (err: any) {
			if (err.code === "P2002") {
				return sendError(event, createError({ statusCode: 400, statusMessage: "Cet email existe déjà." }));
			}
			return sendError(event, createError({ statusCode: 500, statusMessage: "Erreur création utilisateur." }));
		}
	}
});


## server/middleware/auth.global.ts

import { defineEventHandler, sendRedirect } from "h3";
// import { requireUserSession } from "nuxt-auth-utils";

export default defineEventHandler(async (event) => {
	const url = new URL(event.node.req.url || "/", `http://${event.node.req.headers.host || "localhost"}`);
	const { pathname } = url;

	// Protéger toute la zone admin (pages + API)
	if (pathname.startsWith("/admin") || pathname.startsWith("/api/admin")) {
		const { user } = await requireUserSession(event); // 401 si non connecté
		if (!user?.admin) return sendRedirect(event, "/auth/unauthorized", 302);
	}
});


## package.json

{
	"name": "nuxt-app",
	"type": "module",
	"private": true,
	"scripts": {
		"build": "nuxt build",
		"dev": "nuxt dev",
		"generate": "nuxt generate",
		"preview": "nuxt preview",
		"postinstall": "nuxt prepare"
	},
	"dependencies": {
		"@faker-js/faker": "^10.0.0",
		"@prisma/client": "^6.15.0",
		"bcryptjs": "^3.0.2",
		"next-auth": "^4.24.11",
		"nuxt": "^4.1.1",
		"nuxt-better-auth": "^0.3.1",
		"pg": "^8.16.3",
		"vue": "^3.5.20",
		"vue-router": "^4.5.1"
	},
	"devDependencies": {
		"@types/node": "^24.3.1",
		"cross-env": "^10.0.0",
		"nuxt-auth-utils": "^0.5.24",
		"prisma": "^6.15.0",
		"ts-node": "^10.9.2",
		"tsx": "^4.20.5",
		"typescript": "^5.9.2"
	},
	"prisma": {
		"seed": "tsx prisma/seed.ts"
	}
}



# Liste des parties
#
      1 ## app.vue
      4 ## components
      1 ## composables
      1 ## Development Server
      2 ## .env
      1 ## import-test.ts
      1 ## layouts
      1 ## Makefile
      2 ## nuxt.config.ts
      2 ## package.json
     21 ## pages
      3 ## prisma
      1 ## Production
      1 ## README.md
     13 ## server
      1 ## Setup
      2 ## tsconfig.json
      1 ## tsconfig.seed.json
